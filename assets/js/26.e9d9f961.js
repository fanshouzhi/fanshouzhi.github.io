(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{310:function(n,t,a){"use strict";a.r(t);var e=a(10),s=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"创建型模式-创建对象的模式-抽象了实例化的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式-创建对象的模式-抽象了实例化的过程"}},[n._v("#")]),n._v(" 创建型模式: 创建对象的模式，抽象了实例化的过程")]),n._v(" "),t("h4",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[n._v("#")]),n._v(" 单例模式")]),n._v(" "),t("h5",{attrs:{id:"什么是单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是单例模式"}},[n._v("#")]),n._v(" 什么是单例模式？")]),n._v(" "),t("p",[n._v("单例模式定义：保证一个类仅有一个实例，并提供访问此实例的全局访问点。")]),n._v(" "),t("h5",{attrs:{id:"单例模式用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式用途"}},[n._v("#")]),n._v(" 单例模式用途")]),n._v(" "),t("p",[n._v("如果一个类负责连接数据库的线程池、日志记录逻辑等等，此时需要单例模式来保证对象不被重复创建，以达到降低开销的目的。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const Singleton = function() {};\n\nSingleton.getInstance = (function() {\n    // 由于es6没有静态类型,故闭包: 函数外部无法访问 instance\n    let instance = null;\n    return function() {\n        // 检查是否存在实例\n        if (!instance) {\n            instance = new Singleton();\n        }\n        return instance;\n    };\n})();\n\nlet s1 = Singleton.getInstance();\nlet s2 = Singleton.getInstance();\n\nconsole.log(s1 === s2);\n")])])]),t("h4",{attrs:{id:"工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[n._v("#")]),n._v(" 工厂模式")]),n._v(" "),t("h5",{attrs:{id:"什么是工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是工厂模式"}},[n._v("#")]),n._v(" 什么是工厂模式？")]),n._v(" "),t("p",[n._v("工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”")]),n._v(" "),t("p",[n._v("简单来说：就是把new对象的操作包裹一层，对外提供一个可以根据不同参数创建不同对象的函数。")]),n._v(" "),t("h5",{attrs:{id:"工厂模式的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式的优缺点"}},[n._v("#")]),n._v(" 工厂模式的优缺点")]),n._v(" "),t("p",[n._v("优点显而易见，可以隐藏原始类，方便之后的代码迁移。调用者只需要记住类的代名词即可。")]),n._v(" "),t("p",[n._v("由于多了层封装，会造成类的数目过多，系统复杂度增加。")]),n._v(" "),t("h5",{attrs:{id:"es6-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-实现"}},[n._v("#")]),n._v(" ES6 实现")]),n._v(" "),t("p",[n._v("调用者通过向工厂类传递参数，来获取对应的实体。在这个过程中，具体实体类的创建过程，由工厂类全权负责。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n * 实体类：Dog、Cat\n */\n\nclass Dog {\n    run() {\n        console.log("狗");\n    }\n}\n\nclass Cat {\n    run() {\n        console.log("猫");\n    }\n}\n\n/**\n * 工厂类：Animal\n */\n\nclass Animal {\n    constructor(name) {\n        name = name.toLocaleLowerCase();\n        switch (name) {\n            case "dog":\n                return new Dog();\n            case "cat":\n                return new Cat();\n            default:\n                throw TypeError("class name wrong");\n        }\n    }\n}\n\n/**\n * 以下是测试代码\n */\n\nconst cat = new Animal("cat");\ncat.run();\nconst dog = new Animal("dog");\ndog.run();\n')])])]),t("h4",{attrs:{id:"抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[n._v("#")]),n._v(" 抽象工厂模式")]),n._v(" "),t("p",[n._v("抽象工厂模式就是：围绕一个超级工厂类，创建其他工厂类；再围绕工厂类，创建实体类。")]),n._v(" "),t("p",[n._v("相较于传统的工厂模式，它多出了一个超级工厂类。")]),n._v(" "),t("h5",{attrs:{id:"什么是抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是抽象工厂模式"}},[n._v("#")]),n._v(" 什么是抽象工厂模式？")]),n._v(" "),t("p",[n._v("抽象工厂模式就是：围绕一个超级工厂类，创建其他工厂类；再围绕工厂类，创建实体类。")]),n._v(" "),t("p",[n._v("相较于传统的工厂模式，它多出了一个超级工厂类。")]),n._v(" "),t("p",[n._v("它的优缺点与工厂模式类似，这里不再冗赘它的优缺点，下面直接谈一下实现吧。")]),n._v(" "),t("h5",{attrs:{id:"准备实体类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#准备实体类"}},[n._v("#")]),n._v(" 准备实体类")]),n._v(" "),t("p",[n._v("按照之前的做法，这里我们实现几个实体类：Cat 和 Dog 一组、Male 和 Female 一组。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 实体类\n\n//按照之前的做法，这里我们实现几个实体类：Cat 和 Dog 一组、Male 和 Female 一组。\n\nclass Dog {\n    run() {\n        console.log("狗");\n    }\n}\n\nclass Cat {\n    run() {\n        console.log("猫");\n    }\n}\n\n/*************************************************/\n\nclass Male {\n    run() {\n        console.log("男性");\n    }\n}\n\nclass Female {\n    run() {\n        console.log("女性");\n    }\n}\n\n\n// 工厂类\n\n// 假设 Cat 和 Dog，属于 Animal 工厂的产品；Male 和 Female 属于 Person  工厂的产品。所以需要实现 2 个工厂类：Animal 和 Person。\n\n// 由于工厂类上面还有个超级工厂，为了方便工厂类生产实体，工厂类应该提供生产实体的方法接口。\n\n为了更好的约束工厂类的实现，先实现一个抽象工厂类：\n\nclass AbstractFactory {\n    getPerson() {\n        throw new Error("子类请实现接口");\n    }\n\n    getAnimal() {\n        throw new Error("子类请实现接口");\n    }\n}\n\n')])])]),t("h5",{attrs:{id:"接下来-animal-和-dog-实现抽象工厂类-abstractfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接下来-animal-和-dog-实现抽象工厂类-abstractfactory"}},[n._v("#")]),n._v(" 接下来，Animal 和 Dog 实现抽象工厂类(AbstractFactory)：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class PersonFactory extends AbstractFactory {\n    getPerson(person) {\n        person = person.toLocaleLowerCase();\n        switch (person) {\n            case "male":\n                return new Male();\n            case "female":\n                return new Female();\n            default:\n                break;\n        }\n    }\n\n    getAnimal() {\n        return null;\n    }\n}\n\nclass AnimalFactory extends AbstractFactory {\n    getPerson() {\n        return null;\n    }\n\n    getAnimal(animal) {\n        animal = animal.toLocaleLowerCase();\n        switch (animal) {\n            case "cat":\n                return new Cat();\n            case "dog":\n                return new Dog();\n            default:\n                break;\n        }\n    }\n}\n')])])]),t("h5",{attrs:{id:"实现-超级工厂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-超级工厂"}},[n._v("#")]),n._v(" 实现“超级工厂”")]),n._v(" "),t("p",[n._v("超级工厂的实现没什么困难，如下所示：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Factory {\n    constructor(choice) {\n        choice = choice.toLocaleLowerCase();\n        switch (choice) {\n            case "person":\n                return new PersonFactory();\n            case "animal":\n                return new AnimalFactory();\n            default:\n                break;\n        }\n    }\n}\n')])])]),t("p",[n._v("看看怎么使用超级工厂\n实现了那么多，还是要看用例才能更好理解“超级工厂”的用法和设计理念：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n * 以下是测试代码\n */\n\n// 创建person工厂\nconst personFactory = new Factory("person");\n// 从person工厂中创建 male 和 female 实体\nconst male = personFactory.getPerson("male"),\n    female = personFactory.getPerson("female");\n// 输出测试\nmale.run();\nfemale.run();\n\n// 创建animal工厂\nconst animalFactory = new Factory("animal");\n// 从animal工厂中创建 dog 和 cat 实体\nconst dog = animalFactory.getAnimal("dog"),\n    cat = animalFactory.getAnimal("cat");\n// 输出测试\ndog.run();\ncat.run();\n')])])]),t("h3",{attrs:{id:"结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[n._v("#")]),n._v(" 结构型模式:")]),n._v(" "),t("p",[n._v("解决怎样组装现有对象，设计交互方式，从而达到实现一定的功能目的。例如，以封装为目的的适配器和桥接，以扩展性为目的的代理、装饰器")]),n._v(" "),t("h5",{attrs:{id:"享元模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#享元模式"}},[n._v("#")]),n._v(" 享元模式")]),n._v(" "),t("p",[n._v("享元模式：运用共享技术来减少创建对象的数量，从而减少内存占用、提高性能。")]),n._v(" "),t("h5",{attrs:{id:"什么是-享元模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-享元模式"}},[n._v("#")]),n._v(" 什么是“享元模式”？")]),n._v(" "),t("p",[n._v("享元模式：运用共享技术来减少创建对象的数量，从而减少内存占用、提高性能。")]),n._v(" "),t("ul",[t("li",[n._v("享元模式提醒我们将一个对象的属性划分为内部和外部状态。\n"),t("ol",[t("li",[n._v("内部状态：可以被对象集合共享，通常不会改变")]),n._v(" "),t("li",[n._v("外部状态：根据应用场景经常改变")])])]),n._v(" "),t("li",[n._v("享元模式是利用时间换取空间的优化模式。")])]),n._v(" "),t("h5",{attrs:{id:"应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("享元模式虽然名字听起来比较高深，但是实际使用非常容易：只要是需要大量创建重复的类的代码块，均可以使用享元模式抽离内部/外部状态，减少重复类的创建。")]),n._v(" "),t("p",[n._v("为了显示它的强大，下面的代码是简单地实现了大家耳熟能详的“对象池”，以彰显这种设计模式的魅力。")]),n._v(" "),t("h5",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[n._v("#")]),n._v(" 代码实现")]),n._v(" "),t("p",[n._v("通过阅读下方代码可以发现：对于File类，内部状态是pool属性和download方法；外部状态是name和src(文件名和文件链接)。借助对象池，实现了File类的复用")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 对象池\nclass ObjectPool {\n    constructor() {\n        this._pool = []; //\n    }\n\n    // 创建对象\n    create(Obj) {\n        return this._pool.length === 0\n            ? new Obj(this) // 对象池中没有空闲对象，则创建一个新的对象\n            : this._pool.shift(); // 对象池中有空闲对象，直接取出，无需再次创建\n    }\n\n    // 对象回收\n    recover(obj) {\n        return this._pool.push(obj);\n    }\n\n    // 对象池大小\n    size() {\n        return this._pool.length;\n    }\n}\n\n// 模拟文件对象\nclass File {\n    constructor(pool) {\n        this.pool = pool;\n    }\n\n    // 模拟下载操作\n    download() {\n        console.log(`+ 从 ${this.src} 开始下载 ${this.name}`);\n        setTimeout(() => {\n            console.log(`- ${this.name} 下载完毕`); // 下载完毕后, 将对象重新放入对象池\n            this.pool.recover(this);\n        }, 100);\n    }\n}\n\n/****************** 以下是测试函数 **********************/\n\nlet objPool = new ObjectPool();\n\nlet file1 = objPool.create(File);\nfile1.name = "文件1";\nfile1.src = "https://download1.com";\nfile1.download();\n\nlet file2 = objPool.create(File);\nfile2.name = "文件2";\nfile2.src = "https://download2.com";\nfile2.download();\n\nsetTimeout(() => {\n    let file3 = objPool.create(File);\n    file3.name = "文件3";\n    file3.src = "https://download3.com";\n    file3.download();\n}, 200);\n\nsetTimeout(\n    () =>\n        console.log(\n            `${"*".repeat(\n                50\n            )}\\n下载了3个文件，但其实只创建了${objPool.size()}个对象`\n        ),\n    1000\n);\n\n/** 下载结果\n+ 从 https://download1.com 开始下载 文件1\n+ 从 https://download2.com 开始下载 文件2\n- 文件1 下载完毕\n- 文件2 下载完毕\n+ 从 https://download3.com 开始下载 文件3\n- 文件3 下载完毕\n**************************************************\n下载了3个文件，但其实只创建了2个对象\n**/\n')])])]),t("h4",{attrs:{id:"代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[n._v("#")]),n._v(" 代理模式")]),n._v(" "),t("p",[n._v("代理模式的定义：为一个对象提供一种代理以方便对它的访问。")]),n._v(" "),t("h5",{attrs:{id:"什么是代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是代理模式"}},[n._v("#")]),n._v(" 什么是代理模式？")]),n._v(" "),t("p",[n._v("代理模式的定义：为一个对象提供一种代理以方便对它的访问。")]),n._v(" "),t("p",[n._v("代理模式可以解决避免对一些对象的直接访问，以此为基础，常见的有保护代理和虚拟代理。保护代理可以在代理中直接拒绝对对象的访问；虚拟代理可以延迟访问到真正需要的时候，以节省程序开销。")]),n._v(" "),t("h5",{attrs:{id:"代理模式优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式优缺点"}},[n._v("#")]),n._v(" 代理模式优缺点")]),n._v(" "),t("p",[n._v("代理模式有高度解耦、对象保护、易修改等优点。")]),n._v(" "),t("p",[n._v("同样地，因为是通过“代理”访问对象，因此开销会更大，时间也会更慢。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// main.js\nconst myImg = {\n    setSrc(imgNode, src) {\n        imgNode.src = src;\n    }\n};\n\n// 利用代理模式实现图片懒加载\nconst proxyImg = {\n    setSrc(imgNode, src) {\n        myImg.setSrc(imgNode, "./image.png"); // NO1. 加载占位图片并且将图片放入元素\n\n        let img = new Image();\n        img.onload = () => {\n            myImg.setSrc(imgNode, src); // NO3. 完成加载后, 更新  元素中的图片\n        };\n        img.src = src; // NO2. 加载真正需要的图片\n    }\n};\n\nlet imgNode = document.createElement("img"),\n    imgSrc =\n        "https://upload-images.jianshu.io/upload_images/5486602-5cab95ba00b272bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp";\n\ndocument.body.appendChild(imgNode);\n\nproxyImg.setSrc(imgNode, imgSrc);\n\n')])])]),t("div",{staticClass:"language-html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token doctype"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<!")]),t("span",{pre:!0,attrs:{class:"token doctype-tag"}},[n._v("DOCTYPE")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token name"}},[n._v("html")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("html")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[n._v("lang")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')]),n._v("en"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("head")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("meta")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[n._v("charset")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')]),n._v("UTF-8"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("meta")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[n._v("name")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')]),n._v("viewport"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')])]),n._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[n._v("content")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')]),n._v("width=device-width, initial-scale=1.0"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("title")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("Document"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("title")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("head")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("body")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),n._v("script")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[n._v("src")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')]),n._v("./main.js"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),t("span",{pre:!0,attrs:{class:"token script"}}),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("script")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("body")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("</")]),n._v("html")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),n._v("\n")])])]),t("h4",{attrs:{id:"桥接模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式"}},[n._v("#")]),n._v(" 桥接模式")]),n._v(" "),t("p",[n._v("桥接模式：将抽象部分和具体实现部分分离，两者可独立变化，也可以一起工作。")]),n._v(" "),t("h4",{attrs:{id:"什么是桥接模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是桥接模式"}},[n._v("#")]),n._v(" 什么是桥接模式")]),n._v(" "),t("p",[n._v("桥接模式：将抽象部分和具体实现部分分离，两者可独立变化，也可以一起工作。")]),n._v(" "),t("p",[n._v("在这种模式的实现上，需要一个对象担任“桥”的角色，起到连接的作用。")]),n._v(" "),t("h4",{attrs:{id:"应用场景-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("在封装开源库的组件时候，经常会用到这种设计模式。")]),n._v(" "),t("p",[n._v("例如，对外提供暴露一个afterFinish函数,\n如果用户有传入此函数, 那么就会在某一段代码逻辑中调用。")]),n._v(" "),t("p",[n._v("这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。")]),n._v(" "),t("h4",{attrs:{id:"es6-实现-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-实现-2"}},[n._v("#")]),n._v(" ES6 实现")]),n._v(" "),t("p",[n._v("JavaScript 中桥接模式的典型应用是：Array对象上的forEach函数。")]),n._v(" "),t("p",[n._v("此函数负责循环遍历数组每个元素，是抽象部分；\n而回调函数callback就是具体实现部分。")]),n._v(" "),t("p",[n._v("下方是模拟forEach方法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const forEach = (arr, callback) => {\n    if (!Array.isArray(arr)) return;\n\n    const length = arr.length;\n    for (let i = 0; i < length; ++i) {\n        callback(arr[i], i);\n    }\n};\n\n// 以下是测试代码\nlet arr = ["a", "b"];\nforEach(arr, (el, index) => console.log("元素是", el, "位于", index));\n')])])]),t("h4",{attrs:{id:"装饰者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式"}},[n._v("#")]),n._v(" 装饰者模式")]),n._v(" "),t("p",[n._v("装饰者模式：在不改变对象自身的基础上，动态地添加功能代码。")]),n._v(" "),t("h4",{attrs:{id:"什么是-装饰者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-装饰者模式"}},[n._v("#")]),n._v(" 什么是“装饰者模式”？")]),n._v(" "),t("p",[n._v("装饰者模式：在不改变对象自身的基础上，动态地添加功能代码。")]),n._v(" "),t("p",[n._v("根据描述，装饰者显然比继承等方式更灵活，而且不污染原来的代码，代码逻辑松耦合。")]),n._v(" "),t("h4",{attrs:{id:"应用场景-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-3"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("装饰者模式由于松耦合，多用于一开始不确定对象的功能、或者对象功能经常变动的时候。")]),n._v(" "),t("p",[n._v("尤其是在参数检查、参数拦截等场景。")]),n._v(" "),t("h4",{attrs:{id:"代码实现-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现-2"}},[n._v("#")]),n._v(" 代码实现")]),n._v(" "),t("p",[n._v("ES6 的装饰器语法规范只是在“提案阶段”，而且不能装饰普通函数或者箭头函数。")]),n._v(" "),t("p",[n._v("下面的代码，addDecorator可以为指定函数增加装饰器。")]),n._v(" "),t("p",[n._v("其中，装饰器的触发可以在函数运行之前，也可以在函数运行之后。")]),n._v(" "),t("p",[n._v("注意：装饰器需要保存函数的运行结果，并且返回。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const isFn = fn => typeof fn === "function";\n\nconst addDecorator = (fn, before, after) => {\n    if (!isFn(fn)) {\n        return () => {};\n    }\n\n    return (...args) => {\n        let result;\n        // 按照顺序执行“装饰函数”\n        isFn(before) && before(...args);\n        // 保存返回函数结果\n        isFn(fn) && (result = fn(...args));\n        isFn(after) && after(...args);\n        // 最后返回结果\n        return result;\n    };\n};\n\n/******************以下是测试代码******************/\n\nconst beforeHello = (...args) => {\n    console.log(`Before Hello, args are ${args}`);\n};\n\nconst hello = (name = "user") => {\n    console.log(`Hello, ${name}`);\n    return name;\n};\n\nconst afterHello = (...args) => {\n    console.log(`After Hello, args are ${args}`);\n};\n\nconst wrappedHello = addDecorator(hello, beforeHello, afterHello);\n\nlet result = wrappedHello("godbmw.com");\nconsole.log(result);\n')])])]),t("h4",{attrs:{id:"组合模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合模式"}},[n._v("#")]),n._v(" 组合模式")]),n._v(" "),t("p",[n._v("组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。")]),n._v(" "),t("h5",{attrs:{id:"什么是-组合模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-组合模式"}},[n._v("#")]),n._v(" 什么是“组合模式”？")]),n._v(" "),t("p",[n._v("组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。")]),n._v(" "),t("p",[n._v("用小的子对象构造更大的父对象，而这些子对象也由更小的子对象构成")]),n._v(" "),t("p",[n._v("单个对象和组合对象对于用户暴露的接口具有一致性，而同种接口不同表现形式亦体现了多态性")]),n._v(" "),t("h5",{attrs:{id:"应用场景-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-4"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("组合模式可以在需要针对“树形结构”进行操作的应用中使用，例如扫描文件夹、渲染网站导航结构等等。")]),n._v(" "),t("h5",{attrs:{id:"代码实现-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现-3"}},[n._v("#")]),n._v(" 代码实现")]),n._v(" "),t("p",[n._v("这里用代码模拟文件扫描功能，封装了File和Folder两个类。在组合模式下，用户可以向Folder类嵌套File或者Folder来模拟真实的“文件目录”的树结构。")]),n._v(" "),t("p",[n._v("同时，两个类都对外提供了scan接口，File下的scan是扫描文件，Folder下的scan是调用子文件夹和子文件的scan方法。整个过程采用的是深度优先。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 文件类\nclass File {\n    constructor(name) {\n        this.name = name || "File";\n    }\n\n    add() {\n        throw new Error("文件夹下面不能添加文件");\n    }\n\n    scan() {\n        console.log("扫描文件: " + this.name);\n    }\n}\n\n// 文件夹类\nclass Folder {\n    constructor(name) {\n        this.name = name || "Folder";\n        this.files = [];\n    }\n\n    add(file) {\n        this.files.push(file);\n    }\n\n    scan() {\n        console.log("扫描文件夹: " + this.name);\n        for (let file of this.files) {\n            file.scan();\n        }\n    }\n}\n\nlet home = new Folder("用户根目录");\n\nlet folder1 = new Folder("第一个文件夹"),\n    folder2 = new Folder("第二个文件夹");\n\nlet file1 = new File("1号文件"),\n    file2 = new File("2号文件"),\n    file3 = new File("3号文件");\n\n// 将文件添加到对应文件夹中\nfolder1.add(file1);\n\nfolder2.add(file2);\nfolder2.add(file3);\n\n// 将文件夹添加到更高级的目录文件夹中\nhome.add(folder1);\nhome.add(folder2);\n\n// 扫描目录文件夹\nhome.scan();\n')])])]),t("h4",{attrs:{id:"适配器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[n._v("#")]),n._v(" 适配器模式")]),n._v(" "),t("p",[n._v("适配器模式：为多个不兼容接口之间提供“转化器”。")]),n._v(" "),t("h5",{attrs:{id:"什么是适配器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是适配器模式"}},[n._v("#")]),n._v(" 什么是适配器模式？")]),n._v(" "),t("p",[n._v("适配器模式：为多个不兼容接口之间提供“转化器”。")]),n._v(" "),t("p",[n._v("它的实现非常简单，检查接口的数据，进行过滤、重组等操作，使另一接口可以使用数据即可。")]),n._v(" "),t("h5",{attrs:{id:"应用场景-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-5"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("当数据不符合使用规则，就可以借助此种模式进行格式转化。")]),n._v(" "),t("h5",{attrs:{id:"多语言实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多语言实现"}},[n._v("#")]),n._v(" 多语言实现")]),n._v(" "),t("p",[n._v("假设编写了不同平台的音乐爬虫，破解音乐数据。而对外向用户暴露的数据应该是具有一致性。")]),n._v(" "),t("p",[n._v("下面，adapter函数的作用就是转化数据格式。")]),n._v(" "),t("p",[n._v("事实上，在我开发的音乐爬虫库–music-api-next就采用了下面的处理方法。")]),n._v(" "),t("p",[n._v("因为，网易、QQ、虾米等平台的音乐数据不同，需要处理成一致的数据返回给用户，方便用户调用。")]),n._v(" "),t("p",[n._v("ES6 实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const API = {\n    qq: () => ({\n        n: "菊花台",\n        a: "周杰伦",\n        f: 1\n    }),\n    netease: () => ({\n        name: "菊花台",\n        author: "周杰伦",\n        f: false\n    })\n};\n\nconst adapter = (info = {}) => ({\n    name: info.name || info.n,\n    author: info.author || info.a,\n    free: !!info.f\n});\n\n/*************测试函数***************/\n\nconsole.log(adapter(API.qq()));\nconsole.log(adapter(API.netease()));\n\n')])])]),t("h3",{attrs:{id:"行为型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[n._v("#")]),n._v(" 行为型模式:")]),n._v(" "),t("p",[n._v("描述多个类或对象怎样交互以及怎样分配职责")]),n._v(" "),t("h4",{attrs:{id:"命令模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令模式"}},[n._v("#")]),n._v(" 命令模式")]),n._v(" "),t("p",[n._v("命令模式定义：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。")]),n._v(" "),t("h5",{attrs:{id:"什么是-命令模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-命令模式"}},[n._v("#")]),n._v(" 什么是“命令模式”？")]),n._v(" "),t("p",[n._v("命令模式（别名：动作模式、事务模式）定义：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。")]),n._v(" "),t("p",[n._v("简单来说，它的核心思想是：不直接调用类的内部方法，而是通过给“指令函数”传递参数，由“指令函数”来调用类的内部方法。")]),n._v(" "),t("p",[n._v("在这过程中，分别有 3 个不同的主体：调用者、传递者和执行者。")]),n._v(" "),t("h5",{attrs:{id:"应用场景-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-6"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("当想降低调用者与执行者（类的内部方法）之间的耦合度时，可以使用此种设计模式。比如：设计一个命令队列，将命令调用记入日志。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 为了方便演示，mock的假数据\nconst mockData = {\n    10001: {\n        name: "电视",\n        price: 3888\n    },\n    10002: {\n        name: "MacPro",\n        price: 17000\n    }\n};\n\n/**\n * 商品类（执行者）\n */\nclass Mall {\n    static request(id) {\n        if (!mockData[id]) {\n            return `商品不存在`;\n        }\n\n        const { name, price } = mockData[id];\n        return `商品名: ${name} 单价: ${price}`;\n    }\n\n    static buy(id, number) {\n        if (!mockData[id]) {\n            return `商品不存在`;\n        }\n        if (number < 1) {\n            return `至少购买1个商品`;\n        }\n\n        return mockData[id].price * number;\n    }\n}\n')])])]),t("h4",{attrs:{id:"备忘录模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#备忘录模式"}},[n._v("#")]),n._v(" 备忘录模式")]),n._v(" "),t("p",[n._v("备忘录模式：属于行为模式，保存某个状态，并且在需要的时候直接获取，而不是重复计算。")]),n._v(" "),t("h5",{attrs:{id:"什么是备忘录模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是备忘录模式"}},[n._v("#")]),n._v(" 什么是备忘录模式")]),n._v(" "),t("p",[n._v("备忘录模式：属于行为模式，保存某个状态，并且在需要的时候直接获取，而不是重复计算。")]),n._v(" "),t("p",[n._v("注意：备忘录模式实现，不能破坏原始封装。也就是说，能拿到内部状态，将其保存在外部。")]),n._v(" "),t("h5",{attrs:{id:"应用场景-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-7"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("最典型的例子是“斐波那契数列”递归实现。\n不借助备忘录模式，数据一大，就容易爆栈；借助备忘录，算法的时间复杂度可以降低到O(N)\n除此之外，数据的缓存等也是常见应用场景。")]),n._v(" "),t("h5",{attrs:{id:"es6-实现-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-实现-3"}},[n._v("#")]),n._v(" ES6 实现")]),n._v(" "),t("p",[n._v("首先模拟了一下简单的拉取分页数据。\n如果当前数据没有被缓存，那么就模拟异步请求，并将结果放入缓存中；\n如果已经缓存过，那么立即取出即可，无需多次请求。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const fetchData = (() => {\n    // 备忘录 / 缓存\n    const cache = {};\n\n    return page =>\n        new Promise(resolve => {\n            // 如果页面数据已经被缓存, 直接取出\n            if (page in cache) {\n                return resolve(cache[page]);\n            }\n            // 否则, 异步请求页面数据\n            // 此处, 仅仅是模拟异步请求\n            setTimeout(() => {\n                cache[page] = `内容是${page}`;\n                resolve(cache[page]);\n            }, 1000);\n        });\n})();\n\n// 以下是测试代码\nconst run = async () => {\n    let start = new Date().getTime(),\n        now;\n    // 第一次: 没有缓存\n    await fetchData(1);\n    now = new Date().getTime();\n    console.log(`没有缓存, 耗时${now - start}ms`);\n\n    // 第二次: 有缓存 / 备忘录有记录\n    start = now;\n    await fetchData(1);\n    now = new Date().getTime();\n    console.log(`有缓存, 耗时${now - start}ms`);\n};\n\nrun();\n")])])]),t("h4",{attrs:{id:"模板模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板模式"}},[n._v("#")]),n._v(" 模板模式")]),n._v(" "),t("p",[n._v("模板模式是：抽象父类定义了子类需要重写的相关方法。并且这些方法，仍然是通过父类方法调用的。")]),n._v(" "),t("h5",{attrs:{id:"什么是模板模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是模板模式"}},[n._v("#")]),n._v(" 什么是模板模式？")]),n._v(" "),t("p",[n._v("模板模式是：抽象父类定义了子类需要重写的相关方法。并且这些方法，仍然是通过父类方法调用的。")]),n._v(" "),t("p",[n._v("根据描述，父类提供了“模板”并决定是否调用，子类进行具体实现。")]),n._v(" "),t("h5",{attrs:{id:"应用场景-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-8"}},[n._v("#")]),n._v(" 应用场景")]),n._v(" "),t("p",[n._v("一些系统的架构或者算法骨架，由“BOSS”编写抽象方法，具体的实现，交给“小弟们”实现。")]),n._v(" "),t("p",[n._v("而用不用“小弟们”的方法，还是看“BOSS”的心情。")]),n._v(" "),t("h5",{attrs:{id:"es6-实现-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-实现-4"}},[n._v("#")]),n._v(" ES6 实现")]),n._v(" "),t("p",[n._v("Animal是抽象类，Dog和Cat分别具体实现了eat()和sleep()方法。")]),n._v(" "),t("p",[n._v("Dog或Cat实例可以通过live()方法调用eat()和sleep()。")]),n._v(" "),t("p",[n._v("注意：Cat和Dog实例会被自动添加live()方法。不暴露live()是为了防止live()被子类重写，保证父类的控制权。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Animal {\n    constructor() {\n        // this 指向实例\n        this.live = () => {\n            this.eat();\n            this.sleep();\n        };\n    }\n\n    eat() {\n        throw new Error("模板类方法必须被重写");\n    }\n\n    sleep() {\n        throw new Error("模板类方法必须被重写");\n    }\n}\n\nclass Dog extends Animal {\n    constructor(...args) {\n        super(...args);\n    }\n    eat() {\n        console.log("狗吃粮");\n    }\n    sleep() {\n        console.log("狗睡觉");\n    }\n}\n\nclass Cat extends Animal {\n    constructor(...args) {\n        super(...args);\n    }\n    eat() {\n        console.log("猫吃粮");\n    }\n    sleep() {\n        console.log("猫睡觉");\n    }\n}\n\n/********* 以下为测试代码 ********/\n\n// 此时, Animal中的this指向dog\nlet dog = new Dog();\ndog.live();\n\n// 此时, Animal中的this指向cat\nlet cat = new Cat();\ncat.live();\n')])])]),t("h4",{attrs:{id:"状态模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态模式"}},[n._v("#")]),n._v(" 状态模式")]),n._v(" "),t("p",[n._v("状态模式：对象行为是根据状态改变，而改变的。")]),n._v(" "),t("h5",{attrs:{id:"什么是-状态模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-状态模式"}},[n._v("#")]),n._v(" 什么是“状态模式”？")]),n._v(" "),t("p",[n._v("状态模式：对象行为是根据状态改变，而改变的。")]),n._v(" "),t("p",[n._v("正是由于内部状态的变化，导致对外的行为发生了变化。例如：相同的方法在不同时刻被调用，行为可能会有差。")]),n._v(" "),t("h5",{attrs:{id:"优缺点-优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点-优点"}},[n._v("#")]),n._v(" 优缺点 优点：")]),n._v(" "),t("p",[n._v("封装了转化规则，对于大量分支语句，可以考虑使用状态类进一步封装。")]),n._v(" "),t("p",[n._v("每个状态都是确定的，对象行为是可控的。")]),n._v(" "),t("p",[n._v("缺点：\n状态模式的实现关键是将事物的状态都封装成单独的类，这个类的各种方法就是“此种状态对应的表现行为”。因此，程序开销会增大。")]),n._v(" "),t("h5",{attrs:{id:"es6-实现-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-实现-5"}},[n._v("#")]),n._v(" ES6 实现")]),n._v(" "),t("p",[n._v("在 JavaScript 中，可以直接用 JSON 对象来代替状态类。")]),n._v(" "),t("p",[n._v("下面代码展示的就是 FSM（有限状态机）里面有 3")]),n._v(" "),t("p",[n._v("种状态：download、pause、deleted。控制状态转化的代码也在其中。")]),n._v(" "),t("p",[n._v("DownLoad类就是，常说的Context对象，它的行为会随着状态的改变而改变。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const FSM = (() => {\n    let currenState = "download";\n    return {\n        download: {\n            click: () => {\n                console.log("暂停下载");\n                currenState = "pause";\n            },\n            del: () => {\n                console.log("先暂停, 再删除");\n            }\n        },\n        pause: {\n            click: () => {\n                console.log("继续下载");\n                currenState = "download";\n            },\n            del: () => {\n                console.log("删除任务");\n                currenState = "deleted";\n            }\n        },\n        deleted: {\n            click: () => {\n                console.log("任务已删除, 请重新开始");\n            },\n            del: () => {\n                console.log("任务已删除");\n            }\n        },\n        getState: () => currenState\n    };\n})();\n\nclass Download {\n    constructor(fsm) {\n        this.fsm = fsm;\n    }\n\n    handleClick() {\n        const { fsm } = this;\n        fsm[fsm.getState()].click();\n    }\n\n    hanldeDel() {\n        const { fsm } = this;\n        fsm[fsm.getState()].del();\n    }\n}\n\n// 开始下载\nlet download = new Download(FSM);\n\ndownload.handleClick(); // 暂停下载\ndownload.handleClick(); // 继续下载\ndownload.hanldeDel(); // 下载中，无法执行删除操作\ndownload.handleClick(); // 暂停下载\ndownload.hanldeDel(); // 删除任务\n')])])]),t("h4",{attrs:{id:"策略模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[n._v("#")]),n._v(" 策略模式")]),n._v(" "),t("p",[n._v("策略模式定义：就是能够把一系列“可互换的”算法封装起来，并根据用户需求来选择其中一种。")]),n._v(" "),t("h5",{attrs:{id:"什么是策略模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是策略模式"}},[n._v("#")]),n._v(" 什么是策略模式？")]),n._v(" "),t("p",[n._v("策略模式定义：就是能够把一系列“可互换的”算法封装起来，并根据用户需求来选择其中一种。")]),n._v(" "),t("p",[n._v("策略模式的实现核心就是：将算法的使用和算法的实现分离。算法的实现交给策略类。算法的使用交给环境类，环境类会根据不同的情况选择合适的算法。")]),n._v(" "),t("h5",{attrs:{id:"策略模式优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#策略模式优缺点"}},[n._v("#")]),n._v(" 策略模式优缺点")]),n._v(" "),t("p",[n._v("在使用策略模式的时候，需要了解所有的“策略”（strategy）之间的异同点，才能选择合适的“策略”进行调用。")]),n._v(" "),t("p",[n._v("代码实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 策略类\nconst strategies = {\n    A() {\n        console.log("This is stragegy A");\n    },\n    B() {\n        console.log("This is stragegy B");\n    }\n};\n\n// 环境类\nconst context = name => {\n    return strategies[name]();\n};\n\n// 调用策略A\ncontext("A");\n// 调用策略B\ncontext("B");\n')])])]),t("h4",{attrs:{id:"解释器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释器模式"}},[n._v("#")]),n._v(" 解释器模式")]),n._v(" "),t("p",[n._v("解释器模式: 提供了评估语言的语法或表达式的方式。")]),n._v(" "),t("h5",{attrs:{id:"什么是-解释器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-解释器模式"}},[n._v("#")]),n._v(" 什么是“解释器模式？")]),n._v(" "),t("p",[n._v("解释器模式定义: 提供了评估语言的语法或表达式的方式。")]),n._v(" "),t("p",[n._v("这是基本不怎么使用的一种设计模式。确实想不到什么场景一定要用此种设计模式。")]),n._v(" "),t("p",[n._v("实现这种模式的核心是：")]),n._v(" "),t("ol",[t("li",[n._v("抽象表达式：主要有一个interpret()操作")]),n._v(" "),t("li",[n._v("终结符表达式：R = R1 + R2中，R1 R2就是终结符")]),n._v(" "),t("li",[n._v("非终结符表达式：R = R1 - R2中，-就是终结符")]),n._v(" "),t("li",[n._v("环境(Context): 存放文法中各个终结符所对应的具体值。比如前面R1和R2的值。")])]),n._v(" "),t("h5",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[n._v("#")]),n._v(" 优缺点")]),n._v(" "),t("p",[n._v("优点显而易见，每个文法规则可以表述为一个类或者方法。这些文法互相不干扰，符合“开闭原则”。")]),n._v(" "),t("p",[n._v("由于每条文法都需要构建一个类或者方法，文法数量上去后，很难维护。并且，语句的执行效率低（一直在不停地互相调用）。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Context {\n    constructor() {\n        this._list = []; // 存放 终结符表达式\n        this._sum = 0; // 存放 非终结符表达式(运算结果)\n    }\n\n    get sum() {\n        return this._sum;\n    }\n\n    set sum(newValue) {\n        this._sum = newValue;\n    }\n\n    add(expression) {\n        this._list.push(expression);\n    }\n\n    get list() {\n        return [...this._list];\n    }\n}\n\nclass PlusExpression {\n    interpret(context) {\n        if (!(context instanceof Context)) {\n            throw new Error("TypeError");\n        }\n        context.sum = ++context.sum;\n    }\n}\n\nclass MinusExpression {\n    interpret(context) {\n        if (!(context instanceof Context)) {\n            throw new Error("TypeError");\n        }\n        context.sum = --context.sum;\n    }\n}\n\n/** 以下是测试代码 **/\n\nconst context = new Context();\n\n// 依次添加: 加法 | 加法 | 减法 表达式\ncontext.add(new PlusExpression());\ncontext.add(new PlusExpression());\ncontext.add(new MinusExpression());\n\n// 依次执行: 加法 | 加法 | 减法 表达式\ncontext.list.forEach(expression => expression.interpret(context));\nconsole.log(context.sum);\n')])])]),t("h4",{attrs:{id:"订阅-发布模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#订阅-发布模式"}},[n._v("#")]),n._v(" 订阅-发布模式")]),n._v(" "),t("p",[n._v("订阅-发布模式：定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都可以得到通知。")]),n._v(" "),t("h5",{attrs:{id:"什么是-订阅-发布模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-订阅-发布模式"}},[n._v("#")]),n._v(" 什么是“订阅-发布模式”？")]),n._v(" "),t("p",[n._v("订阅-发布模式：定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都可以得到通知。")]),n._v(" "),t("p",[n._v("了解过事件机制或者函数式编程的朋友，应该会体会到“订阅-发布模式”所带来的“时间解耦”和“空间解耦”的优点。借助函数式编程中闭包和回调的概念，可以很优雅地实现这种设计模式。")]),n._v(" "),t("h5",{attrs:{id:"订阅-发布模式-vs-观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#订阅-发布模式-vs-观察者模式"}},[n._v("#")]),n._v(" “订阅-发布模式” vs 观察者模式")]),n._v(" "),t("p",[n._v("订阅-发布模式和观察者模式概念相似，但在订阅-发布模式中，订阅者和发布者之间多了一层中间件：一个被抽象出来的信息调度中心。")]),n._v(" "),t("p",[n._v("但其实没有必要太深究 2 者区别，因为《Head First 设计模式》这本经典书都写了：发布+订阅=观察者模式。其核心思想是状态改变和发布通知。在此基础上，根据语言特性，进行实现即可。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const Event = {\n    clientList: {},\n\n    // 绑定事件监听\n    listen(key, fn) {\n        if (!this.clientList[key]) {\n            this.clientList[key] = [];\n        }\n        this.clientList[key].push(fn);\n        return true;\n    },\n\n    // 触发对应事件\n    trigger() {\n        const key = Array.prototype.shift.apply(arguments),\n            fns = this.clientList[key];\n\n        if (!fns || fns.length === 0) {\n            return false;\n        }\n\n        for (let fn of fns) {\n            fn.apply(null, arguments);\n        }\n\n        return true;\n    },\n\n    // 移除相关事件\n    remove(key, fn) {\n        let fns = this.clientList[key];\n\n        // 如果之前没有绑定事件\n        // 或者没有指明要移除的事件\n        // 直接返回\n        if (!fns || !fn) {\n            return false;\n        }\n\n        // 反向遍历移除置指定事件函数\n        for (let l = fns.length - 1; l >= 0; l--) {\n            let _fn = fns[l];\n            if (_fn === fn) {\n                fns.splice(l, 1);\n            }\n        }\n\n        return true;\n    }\n};\n\n// 为对象动态安装 发布-订阅 功能\nconst installEvent = obj => {\n    for (let key in Event) {\n        obj[key] = Event[key];\n    }\n};\n\nlet salesOffices = {};\ninstallEvent(salesOffices);\n\n// 绑定自定义事件和回调函数\n\nsalesOffices.listen(\n    "event01",\n    (fn1 = price => {\n        console.log("Price is", price, "at event01");\n    })\n);\n\nsalesOffices.listen(\n    "event02",\n    (fn2 = price => {\n        console.log("Price is", price, "at event02");\n    })\n);\n\nsalesOffices.trigger("event01", 1000);\nsalesOffices.trigger("event02", 2000);\n\nsalesOffices.remove("event01", fn1);\n\n// 输出: false\n// 说明删除成功\nconsole.log(salesOffices.trigger("event01", 1000));\n')])])]),t("h4",{attrs:{id:"责任链模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式"}},[n._v("#")]),n._v(" 责任链模式")]),n._v(" "),t("p",[n._v("责任链模式定义：多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止。")]),n._v(" "),t("p",[n._v("其核心思想就是：请求者不必知道是谁哪个节点对象处理的请求。如果当前不符合终止条件，那么把请求转发给下一个节点处理。")]),n._v(" "),t("h5",{attrs:{id:"什么是-责任链模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-责任链模式"}},[n._v("#")]),n._v(" 什么是“责任链模式”？")]),n._v(" "),t("p",[n._v("责任链模式定义：多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止。")]),n._v(" "),t("p",[n._v("其核心思想就是：请求者不必知道是谁哪个节点对象处理的请求。如果当前不符合终止条件，那么把请求转发给下一个节点处理。")]),n._v(" "),t("p",[n._v("而当需求具有“传递”的性质时（代码中其中一种体现就是：多个if、else if、else if、else嵌套），就可以考虑将每个分支拆分成一个节点对象，拼接成为责任链。")]),n._v(" "),t("h5",{attrs:{id:"优点与代价"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点与代价"}},[n._v("#")]),n._v(" 优点与代价")]),n._v(" "),t("p",[n._v("优点：")]),n._v(" "),t("ol",[t("li",[n._v("可以根据需求变动，任意向责任链中添加 / 删除节点对象")]),n._v(" "),t("li",[n._v("没有固定的“开始节点”，可以从任意节点开始")])]),n._v(" "),t("p",[n._v("代价：责任链最大的代价就是每个节点带来的多余消耗。当责任链过长，很多节点只有传递的作用，而不是真正地处理逻辑。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Handler {\n    constructor() {\n        this.next = null;\n    }\n\n    setNext(handler) {\n        this.next = handler;\n    }\n}\n\nclass LogHandler extends Handler {\n    constructor(...props) {\n        super(...props);\n        this.name = "log";\n    }\n\n    handle(level, msg) {\n        if (level === this.name) {\n            console.log(`LOG: ${msg}`);\n            return;\n        }\n        this.next && this.next.handle(...arguments);\n    }\n}\n\nclass WarnHandler extends Handler {\n    constructor(...props) {\n        super(...props);\n        this.name = "warn";\n    }\n\n    handle(level, msg) {\n        if (level === this.name) {\n            console.log(`WARN: ${msg}`);\n            return;\n        }\n        this.next && this.next.handle(...arguments);\n    }\n}\n\nclass ErrorHandler extends Handler {\n    constructor(...props) {\n        super(...props);\n        this.name = "error";\n    }\n\n    handle(level, msg) {\n        if (level === this.name) {\n            console.log(`ERROR: ${msg}`);\n            return;\n        }\n        this.next && this.next.handle(...arguments);\n    }\n}\n\n/******************以下是测试代码******************/\n\nlet logHandler = new LogHandler();\nlet warnHandler = new WarnHandler();\nlet errorHandler = new ErrorHandler();\n\n// 设置下一个处理的节点\nlogHandler.setNext(warnHandler);\nwarnHandler.setNext(errorHandler);\n\nlogHandler.handle("error", "Some error occur");\n')])])]),t("h4",{attrs:{id:"迭代器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[n._v("#")]),n._v(" 迭代器模式")]),n._v(" "),t("p",[n._v("迭代器模式是指提供一种方法顺序访问一个集合对象的各个元素，使用者不需要了解集合对象的底层实现。")]),n._v(" "),t("h5",{attrs:{id:"什么是迭代器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是迭代器模式"}},[n._v("#")]),n._v(" 什么是迭代器模式？")]),n._v(" "),t("p",[n._v("迭代器模式是指提供一种方法顺序访问一个集合对象的各个元素，使用者不需要了解集合对象的底层实现。")]),n._v(" "),t("h5",{attrs:{id:"内部迭代器和外部迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部迭代器和外部迭代器"}},[n._v("#")]),n._v(" 内部迭代器和外部迭代器")]),n._v(" "),t("p",[n._v("内部迭代器：封装的方法完全接手迭代过程，外部只需要一次调用。")]),n._v(" "),t("p",[n._v("外部迭代器：用户必须显式地请求迭代下一元素。熟悉 C++的朋友，可以类比 C++内置对象的迭代器的 end()、next()等方法。")]),n._v(" "),t("p",[n._v("ES6 实现")]),n._v(" "),t("p",[n._v("这里实现的是一个外部迭代器。需要实现边界判断函数、元素获取函数和更新索引函数。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const Iterator = obj => {\n    let current = 0;\n    let next = () => (current += 1);\n    let end = () => current >= obj.length;\n    let get = () => obj[current];\n\n    return {\n        next,\n        end,\n        get\n    };\n};\n\nlet myIter = Iterator([1, 2, 3]);\nwhile (!myIter.end()) {\n    console.log(myIter.get());\n    myIter.next();\n}\n\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);