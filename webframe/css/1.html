<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>有哪些引入方式？通过link和@import引入有什么区别？（* ） | 等风来</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="shortcut icon" href="/favicon.ico" type="iamge/x-icon">
    <meta name="description" content="听云白等风来,观雨落待花开">
    <meta name="keywords" content="等风来 前端 公众号 koala 前端文章">
    
    <link rel="preload" href="/assets/css/0.styles.d264b4b4.css" as="style"><link rel="preload" href="/assets/js/app.31678b28.js" as="script"><link rel="preload" href="/assets/js/2.62c74a10.js" as="script"><link rel="preload" href="/assets/js/19.a9091bf9.js" as="script"><link rel="preload" href="/assets/js/6.a591d526.js" as="script"><link rel="prefetch" href="/assets/js/10.5f4205f9.js"><link rel="prefetch" href="/assets/js/11.525d008d.js"><link rel="prefetch" href="/assets/js/12.3ed2365b.js"><link rel="prefetch" href="/assets/js/13.8c53fe14.js"><link rel="prefetch" href="/assets/js/14.be26c194.js"><link rel="prefetch" href="/assets/js/15.57467872.js"><link rel="prefetch" href="/assets/js/16.05920caa.js"><link rel="prefetch" href="/assets/js/17.8c668bf9.js"><link rel="prefetch" href="/assets/js/18.e11e7c51.js"><link rel="prefetch" href="/assets/js/20.a6246bd5.js"><link rel="prefetch" href="/assets/js/21.39b844ad.js"><link rel="prefetch" href="/assets/js/22.1fc1566e.js"><link rel="prefetch" href="/assets/js/23.6d7cef02.js"><link rel="prefetch" href="/assets/js/24.0f79d0d3.js"><link rel="prefetch" href="/assets/js/25.327f097e.js"><link rel="prefetch" href="/assets/js/26.e9d9f961.js"><link rel="prefetch" href="/assets/js/27.077644c5.js"><link rel="prefetch" href="/assets/js/28.64d65ea5.js"><link rel="prefetch" href="/assets/js/29.0e6c2921.js"><link rel="prefetch" href="/assets/js/3.bd6e5b2c.js"><link rel="prefetch" href="/assets/js/30.9ffdc77b.js"><link rel="prefetch" href="/assets/js/31.b32fb676.js"><link rel="prefetch" href="/assets/js/32.2ce6f6bf.js"><link rel="prefetch" href="/assets/js/33.778e841e.js"><link rel="prefetch" href="/assets/js/34.7bd49029.js"><link rel="prefetch" href="/assets/js/35.1855c4f8.js"><link rel="prefetch" href="/assets/js/4.0f32a644.js"><link rel="prefetch" href="/assets/js/5.6d92e1ac.js"><link rel="prefetch" href="/assets/js/7.277ec606.js"><link rel="prefetch" href="/assets/js/8.ca84de0e.js"><link rel="prefetch" href="/assets/js/9.93419cdf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d264b4b4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">等风来</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/node/" class="nav-link">node</a></div><div class="nav-item"><a href="/webframe/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/database/" class="nav-link">数据库</a></div> <a href="https://github.com/fanshouzhi/fanshouzhi.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/node/" class="nav-link">node</a></div><div class="nav-item"><a href="/webframe/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/database/" class="nav-link">数据库</a></div> <a href="https://github.com/fanshouzhi/fanshouzhi.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <div class="my_introduce" style="padding-left:1rem;"><div class="introduce_component" data-v-7e42bc5a><img src="/images/small.png" alt data-v-7e42bc5a> <div class="intro_content" data-v-7e42bc5a><h3 data-v-7e42bc5a>千里马常有，而伯乐不常有</h3> <p data-v-7e42bc5a> 学习成长之路必将孤独</p></div></div></div> <ul class="sidebar-links"><li><a href="/webframe/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>css</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/webframe/css/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/webframe/css/1.html" aria-current="page" class="active sidebar-link">[css基础知识]</a></li><li><a href="/webframe/css/cssLayout.html" class="sidebar-link">[css布局]</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="有哪些引入方式-通过link和-import引入有什么区别"><a href="#有哪些引入方式-通过link和-import引入有什么区别" class="header-anchor">#</a> 有哪些引入方式？通过link和@import引入有什么区别？（* ）</h2> <ul><li><strong>CSS引入方式有4种</strong> 内联、内嵌、外链、导入</li> <li><strong>外链 link</strong> 除了可以加载css之外,还可以定义rss、rel等属性，没有兼容性问题，支持使用javascript改变样式</li> <li><strong>导入@import</strong> 是css提供的，只能用于加载css，不支持通过javascript修改样式</li> <li>页面被加载的时候，link会被同时加载，而@import则需等到页面加载完后再加载，可能出现无样式网页</li></ul> <h2 id="style-标签写在-body-后和-body-前有什么区别"><a href="#style-标签写在-body-后和-body-前有什么区别" class="header-anchor">#</a> Style 标签写在 body 后和 body 前有什么区别？</h2> <ul><li>一般情况下，页面加载时自上而下的。将style标签至于body之前，为的是先加载样式。</li> <li>若是写在body标签之后，由于浏览器以逐行方式对html文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在windows的IE下可能会出现FOUC现象（页面闪烁）。、</li></ul> <h3 id="什么是-fouc-flash-of-unstyled-content-如何来避免-fouc"><a href="#什么是-fouc-flash-of-unstyled-content-如何来避免-fouc" class="header-anchor">#</a> 什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC</h3> <ul><li>当使用@import导入CSS时，会导致某些页面在IE出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象被称为“文档样式暂时失效”，简称FOUC。</li> <li><strong>产生原因：</strong> 当样式表晚于结构性html加载时，加载到此样式表时，页面将会停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li> <li><strong>解决办法：</strong> 只要在之间加入一个或者元素即可。</li></ul> <h2 id="css选择器"><a href="#css选择器" class="header-anchor">#</a> CSS选择器</h2> <p>CSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析</p> <ul><li>可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；</li> <li>不可继承的样式：border, padding, margin, width, height</li></ul> <h3 id="css选择器种类"><a href="#css选择器种类" class="header-anchor">#</a> CSS选择器种类</h3> <ul><li>id选择器
<ul><li>根据提供的唯一id号快速获取标签对象</li> <li>用于充当label标签for属性的值：用户名：，表示单击此label标签时，id为userid的标签获得焦点</li></ul></li> <li>类选择器 (class )</li> <li>标签选择器 (h1)</li> <li>相邻选择器
<ul><li>直接相邻元素选择器 (h1+p)</li> <li>普通相邻元素选择器 （h2 ~ h2）</li></ul></li> <li>子选择器(ul&gt;li)</li> <li>后代选择器(li a)</li> <li>通配符选择器(*)</li> <li>属性选择器（a[rel = &quot;XXX&quot;]）</li> <li>伪类选择器( :hover :first-child ···)</li> <li>伪元素选择器( :before :after ···)</li> <li>分组选择器</li></ul> <h3 id="css选择器优先级"><a href="#css选择器优先级" class="header-anchor">#</a> CSS选择器优先级</h3> <ul><li><strong>优先级由高到低</strong>   !important &gt; 内联style &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器&gt;继承</li> <li><strong>优先级算法(权重)</strong> <ul><li>元素选择符的权值
<ul><li>元素标签（派生选择器）：1</li> <li>class选择符：10</li> <li>id选择符：100</li> <li>内联样式最大：1000</li></ul></li> <li>继承得到的样式的优先级最低</li> <li>比较多个权重相同的CSS选择器优先级，定义的位置决定一切。从位置上由高到低分为六级：</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>      1. 位于&lt;head/&gt;标签里的&lt;style/&gt;中所定义的CSS拥有最高级的优先权。
      2. 位于 &lt;style/&gt;标签中的 @import 引入样式表所定义。
      3. 由&lt;link/&gt;标签所引入的样式表定义。
      4. 由&lt;link/&gt;标签所引入的样式表内的 @import 导入样式表定义。
      5. 用户设定。
      6. 浏览器默认。
复制代码
</code></pre></div><ul><li>同位置情况下样式定义最近者为准（优先级相同，选择最后出现的样式）</li></ul> <h2 id="css伪类和伪元素"><a href="#css伪类和伪元素" class="header-anchor">#</a> CSS伪类和伪元素</h2> <h3 id="css伪元素"><a href="#css伪元素" class="header-anchor">#</a> CSS伪元素</h3> <ul><li><strong>::selection</strong> 选择被用户选取的元素部分</li> <li><strong>:first-line</strong> 选择元素中的第一行</li> <li><strong>:first-letter</strong> 选择元素中的第一个字符</li> <li><strong>:after</strong> 在元素在该元素之后添加内容</li> <li><strong>:before</strong> 在元素在该元素之前添加内容</li></ul> <h3 id="css伪类"><a href="#css伪类" class="header-anchor">#</a> CSS伪类</h3> <ul><li><strong>:root</strong> 选择文档的根元素，等同于html元素</li> <li><strong>:empty</strong> 选择没有子元素的元素</li> <li><strong>:target</strong> 选取当前活动的目标元素</li> <li><strong>:not(selector)</strong> 选择除 selector 元素意外的元素</li> <li><strong>:enabled</strong> 选择可用的表单元素</li> <li><strong>:disabled</strong> 选择禁用的表单元素</li> <li><strong>:checked</strong> 选择被选中的表单元素</li> <li><strong>:first-child</strong> 选取当前选择器下第一个元素。</li> <li><strong>:last-child</strong> 和 first-child 相反，选取当前选择器下最后一个元素。</li> <li><strong>:only-child</strong> 选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效。</li> <li><strong>:only-of-type</strong> 选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以。</li></ul> <h4 id="静态伪类-只用于a标签"><a href="#静态伪类-只用于a标签" class="header-anchor">#</a> 静态伪类（只用于a标签）</h4> <ul><li>:link 指示这个“超链接”（即 a 元素里有一个 href 属性）未被访问</li> <li>:visited 指示这个“超链接”已被访问</li></ul> <h4 id="动态伪类-使用时鼓励-lvht-顺序"><a href="#动态伪类-使用时鼓励-lvht-顺序" class="header-anchor">#</a> 动态伪类（使用时鼓励“LVHT”顺序）</h4> <ul><li>:focus 指示这个元素拥有输入“焦点”——即可以接受键盘输入，或通过某种方式可以激活</li> <li>:hover 指示当鼠标停留在这个元素上时，外观可以作相应改变</li> <li>:active 指示这个元素可以被用户输入“激活”，如，用户停留在一个超链接上，当点击鼠标时，这个链接就会“激活”</li></ul> <h3 id="伪类和伪元素的根本区别"><a href="#伪类和伪元素的根本区别" class="header-anchor">#</a> 伪类和伪元素的根本区别</h3> <ul><li><strong>它们是否创造了新的元素(抽象)</strong>。</li> <li>从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。</li> <li>伪元素在一个选择器里只能出现一次，并且只能出现在末尾。</li> <li>伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。</li> <li>伪类用一个冒号表示 :first-child，伪元素则使用两个冒号表示 ::first-line(为了向下兼容，现在的浏览器中伪元素选择器用单冒号和双冒号都可以)。</li></ul> <h2 id="css盒模型"><a href="#css盒模型" class="header-anchor">#</a> CSS盒模型</h2> <h3 id="盒模型分类"><a href="#盒模型分类" class="header-anchor">#</a> 盒模型分类</h3> <ul><li>IE盒模型（怪异盒模型）
<ul><li>width = border + padding + content</li> <li>一个盒子的宽度 = width + margin</li></ul></li> <li>W3C盒模型（标准盒模型）
<ul><li>width = content</li> <li>一个盒子的宽度 = width + padding + border + margin</li></ul></li></ul> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyg953lztj30hf0kigu0.jpg" alt="image-20200721114929900"></p> <h3 id="转换盒模型"><a href="#转换盒模型" class="header-anchor">#</a> 转换盒模型</h3> <p>Css中默认的盒模型是W3C盒模型，两者间的转换可以通过设置属性box-sizing来转换</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">box-sizing</span><span class="token punctuation">:</span> content-box<span class="token punctuation">;</span> // W3C盒模型标准 
<span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span> // IE盒模型标准
</code></pre></div><h3 id="盒子一些相关宽度"><a href="#盒子一些相关宽度" class="header-anchor">#</a> 盒子一些相关宽度</h3> <ul><li>clientWidth = width+左右padding</li> <li>offsetWidth = width + 左右padding + 左右boder</li> <li>scrollWidth：获取指定标签内容层的真实宽度（可视区域宽度+被隐藏区域宽度）</li></ul> <h3 id="边界塌陷"><a href="#边界塌陷" class="header-anchor">#</a> 边界塌陷</h3> <p>CSS 中存在一个 margin collapse，即边界塌陷或者说边界重叠。
只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p> <h4 id="并排-div-边界塌陷-兄弟"><a href="#并排-div-边界塌陷-兄弟" class="header-anchor">#</a> 并排 DIV 边界塌陷（兄弟）</h4> <p>对于上下两个并排的 DIV 块而言，上面 DIV 的 margin-bottom 和下面 DIV 的 margin-top 会塌陷，会取<strong>上下两者 margin 里最大值作为显示值</strong>，只设置单个margin。</p> <h4 id="包含元素盒子塌陷-父子"><a href="#包含元素盒子塌陷-父子" class="header-anchor">#</a> 包含元素盒子塌陷（父子）</h4> <p>父级div中没有border，padding，inlinecontent，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content(文本)中的其中一个，然后按此div 进行margin。</p> <h4 id="解决方法"><a href="#解决方法" class="header-anchor">#</a> 解决方法</h4> <ul><li>为父盒子设置border，为外层添加border后父子盒子就不是真正意义上的贴合 （可以设置成透明：border: 1px solid transparent）</li> <li>为父盒子添加overflow: hidden;</li> <li>为父盒子设定padding值；</li> <li>为父盒子添加position：fixed；</li></ul> <h3 id="负值作用"><a href="#负值作用" class="header-anchor">#</a> 负值作用</h3> <ul><li>负 marign实现元素的水平垂直居中</li> <li>负 marign隐藏列表 li 首尾多余的边框</li> <li>负 text-indent 实现文字的隐藏</li> <li>负的 z-index 参与层叠上下文排序</li> <li>定位中的left、right、top、bottom</li></ul> <h2 id="position-定位"><a href="#position-定位" class="header-anchor">#</a> position 定位</h2> <h3 id="static-普通流定位"><a href="#static-普通流定位" class="header-anchor">#</a> static(普通流定位)</h3> <p>默认定位</p> <h3 id="relative-相对定位"><a href="#relative-相对定位" class="header-anchor">#</a> relative(相对定位)</h3> <ul><li>相对<strong>本元素</strong>的<strong>左上角</strong>进行定位（相对于自身位置进行定位），本元素需要设置position为relative，top、left、bottom、right都可以有值。</li> <li>虽然经过定位后，位置可能会移动，但是本元素并<strong>没有脱离文档流</strong>，还占有原来的页面空间。</li></ul> <h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="header-anchor">#</a> absolute(绝对定位)</h3> <ul><li>相对于祖代中有relative(相对定位)并且离本元素层级关系上是最近的元素的<strong>左上角</strong>进行定位，如果在祖代元素中没有有relative定位的，就默认相对于body进行定位。</li> <li>元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</li> <li>绝对定位是<strong>脱离文档流</strong>的，与浮动定位是一样的效果，会压在非定位元素的上方。</li></ul> <h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="header-anchor">#</a> fixed(固定定位)</h3> <p>类似于absolute定位，但是是相对于浏览器窗口进行定位</p> <h3 id="inherit"><a href="#inherit" class="header-anchor">#</a> inherit</h3> <p>继承父级元素position属性值</p> <h3 id="sticky-额外补充"><a href="#sticky-额外补充" class="header-anchor">#</a> sticky （额外补充）</h3> <p>粘性的-集合了flex和relative,参考<a href="https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/" target="_blank" rel="noopener noreferrer">杀了个回马枪，还是说说position:sticky吧<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="float浮动"><a href="#float浮动" class="header-anchor">#</a> float浮动</h2> <ul><li>有两个取值：left(左浮动)和right(右浮动)。</li> <li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li> <li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li></ul> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <p>最初的优点就是在图文混排的时候可以很好的使文字周围在图片周围。另外当元素浮动了起来之后，它具有块级元素的一些性质例如可以设置宽高等，但它与inline- block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题。</p> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷为0(<strong>盒子塌陷</strong>)。
<strong>▲ 注意：设置元素浮动后，该元素的display值会变为block</strong></p> <h3 id="清除浮动"><a href="#清除浮动" class="header-anchor">#</a> <strong>清除浮动（*）</strong></h3> <ul><li>盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，非自适应</li> <li>父级元素设置高度</li> <li>父级元素触发BFC（Float，Overflow: Hidden | Visible，Display: Flex | Grid）</li></ul> <div class="language-css extra-class"><pre class="language-css"><code>&lt;div class=<span class="token string">&quot;parent&quot;</span> style=<span class="token string">&quot;overflow:hidden&quot;</span>&gt;     
    &lt;div class=<span class="token string">&quot;f&quot;</span>&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre></div><ul><li>添加额外标签</li></ul> <div class="language-css extra-class"><pre class="language-css"><code>&lt;div class=<span class="token string">&quot;parent&quot;</span>&gt;    //添加额外标签并且添加clear属性    
    &lt;div class=<span class="token string">&quot;f&quot;</span>&gt;&lt;/div&gt;   
&lt;/div&gt;
&lt;div style=<span class="token string">&quot;clear:both&quot;</span>&gt;&lt;/div&gt;
</code></pre></div><ul><li><strong>建立伪类选择器清除浮动（推荐）</strong></li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">//添加:after伪元素
.parent:after</span><span class="token punctuation">{</span>    
    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token comment">/* 设置添加子元素的内容是空 */</span>  
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span> <span class="token comment">/* 设置添加子元素为块级元素 */</span>       
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> <span class="token comment">/* 设置添加的子元素的高度0 */</span>     
    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/* 设置添加子元素看不见 */</span>     
    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span> <span class="token comment">/* 设置clear：both */</span>
<span class="token punctuation">}</span>
&lt;div class=<span class="token string">&quot;parent&quot;</span>&gt;    
    &lt;div class=<span class="token string">&quot;f&quot;</span>&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre></div><h2 id="display-布局"><a href="#display-布局" class="header-anchor">#</a> display 布局</h2> <table><thead><tr><th style="text-align:left;"><strong>值</strong></th> <th style="text-align:left;"><strong>描述</strong></th></tr></thead> <tbody><tr><td style="text-align:left;">none</td> <td style="text-align:left;">元素会被隐藏，不显示</td></tr> <tr><td style="text-align:left;">inline</td> <td style="text-align:left;">元素会被设置为内联元素，内部按行从左向右排列（元素前后没有换行符）</td></tr> <tr><td style="text-align:left;">block</td> <td style="text-align:left;">元素会被设置为块级元素，内部按列从上到下排列（元素前后带有换行符）</td></tr> <tr><td style="text-align:left;">inline-block</td> <td style="text-align:left;">元素会被设置为行内块级元素，不会独占一行的块级元素</td></tr> <tr><td style="text-align:left;">list-item</td> <td style="text-align:left;">元素会作为列表显示</td></tr> <tr><td style="text-align:left;">table</td> <td style="text-align:left;">元素会作为块级表格来显示（类似table），表格前后带有换行符</td></tr> <tr><td style="text-align:left;">flex</td> <td style="text-align:left;">元素会进入flex布局模式</td></tr></tbody></table> <h3 id="inline、block、inline-block三者区"><a href="#inline、block、inline-block三者区" class="header-anchor">#</a> inline、block、inline-block三者区</h3> <h4 id="block块级特点"><a href="#block块级特点" class="header-anchor">#</a> block块级特点：</h4> <ul><li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）</li> <li>元素的高度、宽度、行高以及顶和底边距都可设置。</li> <li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li></ul> <h4 id="inline内联特点"><a href="#inline内联特点" class="header-anchor">#</a> inline内联特点：</h4> <ul><li>和其他元素都在一行上；</li> <li>元素的高度、宽度及顶部和底部边距不可设置；</li> <li>元素的宽度就是它包含的文字或图片的宽度，不可改变。</li></ul> <h4 id="inline-block-特点"><a href="#inline-block-特点" class="header-anchor">#</a> inline-block 特点：</h4> <ul><li>inline-block内联块状元素同时具备内联元素、块状元素的特点。</li> <li>和其他元素都在一行上；</li> <li>元素的高度、宽度、行高以及顶和底边距都可设置。</li></ul> <h3 id="使用-display-inline-block-会产生什么问题-又如何解决"><a href="#使用-display-inline-block-会产生什么问题-又如何解决" class="header-anchor">#</a> <strong>使用 display:inline-block 会产生什么问题？又如何解决？（*）</strong></h3> <p>两个inline-block元素放到一起会产生一段空白。</p> <h4 id="产生空白的原因"><a href="#产生空白的原因" class="header-anchor">#</a> 产生空白的原因</h4> <p>元素被当成行内元素放置的时候，元素之间的空白符（空格，回车换行等）都会被浏览器处理，根据CSS中空白属性的处理方式（否则是正常，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符较长一定长度，所以inline-block的元素之间就出现了空隙。</p> <h4 id="解决办法"><a href="#解决办法" class="header-anchor">#</a> 解决办法</h4> <ul><li>将子元素标签的结束符和下一个标签的开始符写在同一行或把所有子标签写在同一行</li> <li>父元素中设置字体大小：0，在子元素上重置正确的字体大小</li> <li>为子元素设置float：left</li></ul> <h2 id="flex布局"><a href="#flex布局" class="header-anchor">#</a> flex布局</h2> <p>该布局提供了一种更高效的方法对容器中的项目进行布局、对齐和分配空间，他没有方向上的限制，可以由开发人员自由操作（子元素的 vertical-align、float、clear 属性会失效）。</p> <h3 id="容器属性-6个"><a href="#容器属性-6个" class="header-anchor">#</a> 容器属性（6个）</h3> <ul><li><strong>flex-direction</strong>** 决定主轴方向（容器排列方向）**</li></ul> <p>flex-direction: row | row-reverse | column | column-reverse;</p> <ul><li><strong>flex-wrap</strong>** 如果一条轴线排不下，定义换行规则**</li></ul> <p>flex-wrap: nowrap | wrap | wrap-reverse;</p> <ul><li><strong>flex-flow</strong>** flex-direction和flex-wrap的简写形式**</li></ul> <p>flex-flow: flex-direction||flex-wrap;</p> <ul><li><strong>justify-content</strong>** 定义容器在主轴上的对齐方式**</li></ul> <p>justify-content: flex-start | flex-end | center | space-between | space-around;</p> <ul><li><strong>align-items</strong>** 定义容器在交叉轴上的对齐方式**</li></ul> <p>align-items: flex-start | flex-end | center | baseline | stretch;</p> <ul><li><strong>align-content</strong>** 定义多根轴线的对齐方式，如果容器只有一根轴线，该属性不起作用**</li></ul> <p>align-content: flex-start | flex-end | center | space-between | space-around |;</p> <h3 id="项目属性-6个"><a href="#项目属性-6个" class="header-anchor">#</a> 项目属性（6个）</h3> <ul><li><strong>order</strong> 定义项目的排列顺序，数值越小，排列越靠前，默认为0</li> <li><strong>flex-grow</strong> 定义项目的放大比例，默认为0（即如果存在剩余空间，也不放大）</li> <li><strong>flex-shrink</strong> 定义项目的缩小比例，默认为1（即如果空间不足，该项目将缩小）</li> <li><strong>flex-basis</strong> 定义了在分配多余空间之前，项目占据的主轴空间。默认值为auto（项目本来大小）</li> <li><strong>align-self</strong>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性，默认值为auto（表示继承父元素align-items属性，如果没有父元素，等同于stretch）</li></ul> <p>align-self: auto | flex-start | flex-end | center | baseline | stretch;</p> <ul><li><strong>flex</strong> 是flex-grow、flex-shrink和flex-basis的简写，<strong>默认值为 0 1 auto</strong></li></ul> <p>flex: none | [ 'flex-grow' 'flex-shrink'? || 'flex-basis']
该属性有两个快捷值: <strong>auto(1 1 auto)</strong> 和 <strong>none(0 0 auto)</strong>
建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p> <h2 id="overflow溢出"><a href="#overflow溢出" class="header-anchor">#</a> overflow溢出</h2> <ul><li>scroll：必定出现滚动条</li> <li>auto：子元素内容大于父元素时出现滚动条</li> <li>visible：溢出的内容出现在父元素之外</li> <li>hidden：溢出时隐藏</li></ul> <h3 id="如何实现-单行文本溢出加"><a href="#如何实现-单行文本溢出加" class="header-anchor">#</a> 如何实现：单行文本溢出加 ...(*)</h3> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span> <span class="token comment">/* 首先，强制文本不换行；*/</span> 
<span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/*其次，隐藏溢出； */</span>  
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span> <span class="token comment">/*最后，对溢出的文本用 ellipsis 省略号代替。 */</span>
</code></pre></div><h3 id="全屏滚动的原理-需要哪些css属性"><a href="#全屏滚动的原理-需要哪些css属性" class="header-anchor">#</a> 全屏滚动的原理？需要哪些css属性？</h3> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <p>类似于轮播图，整体元素一直排列下去，假设有5个需要展示的全屏页面，那么高度将会是500%，但我们只能展示100%，剩下的内容可以通过transform进行Y轴定位，也可以通过margin-top实现</p> <h4 id="涉及css属性"><a href="#涉及css属性" class="header-anchor">#</a> 涉及css属性</h4> <p>overflow:hidden | transition:all 1000ms ease</p> <h2 id="bfc块级格式上下文"><a href="#bfc块级格式上下文" class="header-anchor">#</a> BFC块级格式上下文</h2> <h3 id="什么是bfc"><a href="#什么是bfc" class="header-anchor">#</a> 什么是BFC？</h3> <ul><li>BFC直译为<strong>块级格式化上下文</strong>，它是一个独立的渲染区域，只有Block-level box参与，它规定了<strong>内部的Block-level Box</strong>如何布局，并且与外部毫不相干。</li> <li>W3C对BFC的定义如下：浮动元素和绝对定位元素，非块级盒子的块级容器（例如，内联块，表单元格和表标题），以及溢出值不为“可见”的块级盒子，，都会为他们的内容创建新的BFC（阻止Fromatting上下文，即块级格式文本）。</li> <li><strong>注意</strong>：可以把BFC理解为一个大的盒子，其内部是由Block-level box组成的</li></ul> <h3 id="如何触发bfc"><a href="#如何触发bfc" class="header-anchor">#</a> 如何触发BFC？（*）</h3> <ul><li>根元素 → 根元素（html）就是最大的BFC</li> <li>position设置为 fixed 或者 absolute</li> <li>display设置为 inline-block 、table-block 、table-caption</li> <li>overflow的值不为visible</li> <li>float的值不为none</li></ul> <h3 id="bfc布局规则"><a href="#bfc布局规则" class="header-anchor">#</a> BFC布局规则：</h3> <ol><li>内部的Box会在垂直方向，一个接一个地放置。</li> <li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li> <li>每个元素的margin box的左边， 与包含块的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li> <li>BFC的区域不会与外部float box重叠。</li> <li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li> <li>计算BFC的高度时，浮动元素也参与计算</li></ol> <h3 id="bfc的作用及原理"><a href="#bfc的作用及原理" class="header-anchor">#</a> BFC的作用及原理：</h3> <ul><li>自适应两栏布局</li> <li>清除内部浮动</li> <li>防止垂直 margin 重叠（将垂直方向上的<strong>盒子放在不同的 BFC 中</strong>，margin 就不会重叠了。）</li> <li>BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</li></ul> <h2 id="ifc行内格式上下文"><a href="#ifc行内格式上下文" class="header-anchor">#</a> IFC行内格式上下文</h2> <ul><li>内部的盒子一个接着一个地排列，起点是包含块的顶点。</li> <li>如果一行放不下内容，那么会被“拆”开放到下一行。</li> <li>只有水平方向上的 Margin 会在盒子中保留。</li> <li>Padding 和 Border 不会撑开行高。</li></ul> <h2 id="z-index层叠上下文"><a href="#z-index层叠上下文" class="header-anchor">#</a> <strong>z-index层叠上下文</strong></h2> <ul><li>z-index 可以解决元素之间覆盖顺序的问题，设置它的层叠顺序。</li> <li>如果元素是没有定位的，对其设置的 z-index 会是无效的。</li></ul> <h3 id="元素层叠时-覆盖关系准则"><a href="#元素层叠时-覆盖关系准则" class="header-anchor">#</a> 元素层叠时，覆盖关系准则（*）</h3> <h4 id="同父同级元素"><a href="#同父同级元素" class="header-anchor">#</a> 同父同级元素</h4> <ul><li>当具有明显的层叠水平标示时，如识别的z-index值
<ul><li>z-index大的覆盖小的，数值越大，越靠近视觉点。</li> <li>z-index相同时，在DOM流中处于后面会覆盖前面。</li></ul></li> <li>都没有设置 z-index时，使用默认值，一个定位一个没有定位，那么定位覆盖未定位元素。</li> <li>都没有定位且发生位置重合现象时，在DOM流中处于后面会覆盖前面。</li></ul> <h4 id="父子层级元素"><a href="#父子层级元素" class="header-anchor">#</a> 父子层级元素</h4> <ul><li>不同父元素，只要父元素越大，那么整体就越靠近视觉点，而不管其子元素大小情况。</li> <li>如果父元素 z-index 有效，那么子元素无论是否设置 z-index 都和父元素一致，会在父元素上方；</li> <li>如果父元素 z-index 失效（未定位或者使用默认值），那么定位子元素的 z-index 设置生效。</li></ul> <h3 id="层叠上下文的创建"><a href="#层叠上下文的创建" class="header-anchor">#</a> 层叠上下文的创建</h3> <h4 id="根层叠上下文"><a href="#根层叠上下文" class="header-anchor">#</a> 根层叠上下文</h4> <p>指的是页面根元素，也就是滚动条的默认的始作俑者元素。这就是为什么，绝对定位元素在left/top等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p> <h4 id="定位元素与传统层叠上下文"><a href="#定位元素与传统层叠上下文" class="header-anchor">#</a> 定位元素与传统层叠上下文</h4> <p>对于包含有position:relative/position:absolute/position:fixed的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。</p> <h4 id="css3与新时代的层叠上下文"><a href="#css3与新时代的层叠上下文" class="header-anchor">#</a> CSS3与新时代的层叠上下文</h4> <p>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，<a href="https://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="noopener noreferrer">CSS3 transform对overflow隐藏对position:fixed定位的影响<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>等。而这里，层叠上下文这一块的影响要更加广泛与显著。
如下：</p> <ol><li>z-index值不为auto的flex项(父元素display:flex|inline-flex).</li> <li>元素的opacity值不是1.</li> <li>元素的transform值不是none.</li> <li>元素mix-blend-mode值不是normal.</li> <li>元素的filter值不是none.</li> <li>元素的isolation值是isolate.</li> <li>will-change指定的属性值为上面任意一个。</li> <li>元素的-webkit-overflow-scrolling设为touch</li></ol> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyg3zrifaj30fg0a141g.jpg" alt="image-20200721114416166"></p> <h2 id="css管理方案"><a href="#css管理方案" class="header-anchor">#</a> CSS管理方案</h2> <h3 id="itcss"><a href="#itcss" class="header-anchor">#</a> ITCSS</h3> <p>ITCSS（Inverted Triangle CSS）通过规范样式文件的组织结构来适应项目中特殊性不断增加的选择器。见以下倒立的三角形，其中每一层都代表一种样式的概念结构：</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyg5sh254j30hi098wel.jpg" alt="image-20200721114514148"></p> <ul><li>Settings：Global variables、Config switches</li> <li>Tools：Mixins、Functions</li> <li>Generic：Ground-zero styles（Normalize.css，resets.css）</li> <li>Base：Unclassed HTML elements（Type selectors）</li> <li>Objects：Cosmetic-free design patterns</li> <li>Components：Designed components</li> <li>Trumps：Helpers、Overrides</li></ul> <p>层级自上而下，选择器影响的 DOM 数量也越来越少，同时选择器特殊性递增。修改某个样式时我们可以轻易从相关组织文件中做出修改，而不影响其它样式，或是导致 CSS 样式继承的崩塌。</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyg66jb9tj30hb0c6tbr.jpg" alt="image-20200721114638654"></p> <h3 id="命名方案"><a href="#命名方案" class="header-anchor">#</a> 命名方案</h3> <p><strong>解决的主要是命名冲突和复用两个问题</strong>，在众多解决方案中，没有绝对的优劣。还是要结合自己的场景来决定。</p> <h4 id="oocss"><a href="#oocss" class="header-anchor">#</a> OOCSS</h4> <ul><li>面对对象的规则，主要的原则是两种：分离结构和外观，分离容器和内容。</li> <li>分离结构和外观：增加可重复的设计单元，同时去推进产品和ui对这方面的思考，比如下面的css使用时对象模式的命名和模块化规则。</li> <li>分离容器和内容：指的是样式的使用不以元素位置唯一匹配，在任何位置你都可以使用这个样式，如果你不适用这个样式，会保持默认的样式。</li></ul> <h4 id="smacss"><a href="#smacss" class="header-anchor">#</a> SMACSS</h4> <ul><li>sma和oocss有很多类似之处，但区分的地方有很多，主要是对样式的分类。分别是：基础、布局、模块、状态、主题</li> <li>与oocss相比，其实大部分设计思路是一样的，以一个类作为css的作用域（作用域就是两个限制，1 不符合场景时限制禁止使用 2 符合场景时要正确的使用），另外的区别就是针对皮肤和状态的不同书写规则
<ul><li><strong>基础</strong>：可以适用于任何位置，我也称全局样式</li> <li><strong>布局</strong>：主要是用来实现不同的特色布局，提高布局的复用率，</li> <li><strong>模块</strong>：设计中的模块化，可重复使用的一个单元，一般是dom+css的耦合绑定。</li> <li><strong>状态</strong>：描述在特定状态下的布局或者模块的特殊化表现，这里我觉得要推荐下《css禅意花园》，在dom结构不变的情况下，可以通过css的皮肤化实现样式的改版。</li> <li><strong>主题</strong>：与状态相比更加定制的是，我们会针对有些特殊的模块，进行主题的设置，包括一系列的颜色、尺寸、交互等进行重度设计，参数化设计。</li></ul></li></ul> <h4 id="bem"><a href="#bem" class="header-anchor">#</a> BEM</h4> <p>bem就是块、元素、修饰符的思维去写样式。它不涉及具体的css结构，只是建议你如何命名css。</p> <ul><li>块级：所属组件的名称</li> <li>元素：元素在组件里的名称</li> <li>修饰符：任何与元素修饰相关的类</li></ul> <h4 id="style-components"><a href="#style-components" class="header-anchor">#</a> Style-Components</h4> <p>彻底抛弃 CSS，用 JavaScript 写 CSS 规则</p> <h4 id="css-modules"><a href="#css-modules" class="header-anchor">#</a> CSS Modules</h4> <p>使用JS编译原生的CSS文件，使其具备模块化的能力</p> <h3 id="按需加载"><a href="#按需加载" class="header-anchor">#</a> 按需加载</h3> <ul><li>使用require.js按需加载CSS</li> <li>webpack配置CSS的按需加载</li></ul> <h2 id="css浏览器兼容性"><a href="#css浏览器兼容性" class="header-anchor">#</a> CSS浏览器兼容性</h2> <h3 id="浏览器css样式初始化"><a href="#浏览器css样式初始化" class="header-anchor">#</a> <strong>浏览器CSS样式初始化</strong></h3> <p>由于每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化，在所有CSS开始前，先把marin和padding都设为0，以防不同浏览器的显示效果不一样（推荐初始化库Normalize.css）。</p> <h3 id="浏览器私有属性"><a href="#浏览器私有属性" class="header-anchor">#</a> <strong>浏览器私有属性</strong></h3> <ul><li>我们经常会在某个CSS的属性前添加一些前缀，比如-webkit-，-moz- ，-ms-，这些就是浏览器的私有属性，出现私有属性的原因是制定HTML和CSS标准的组织W3C动作是很慢的。</li> <li>通常，有W3C组织成员提出一个新属性，比如说圆角border-radius，大家都觉得好，但W3C制定标准，要走很复杂的程序，审查等。而浏览器商市场推广时间紧，如果一个属性已经够成熟了，就会在浏览器中加入支持。</li></ul> <p>为避免日后W3C公布标准时有所变更，会加入一个私有前缀，比如-webkit-border-radius，通过这种方式来提前支持新属性。等到日后W3C公布了标准，border-radius的标准写法确立之后，再让新版的浏览器支持border-radius这种写法。常用的前缀有：</p> <ul><li>-moz代表firefox浏览器私有属性</li> <li>-ms代表IE浏览器私有属性</li> <li>-webkit代表chrome、safari私有属性</li> <li>-o代表opera私有属性</li></ul> <p><strong>对于私有属性的顺序要注意，把标准写法放到最后，兼容性写法放到前面</strong></p> <div class="language-css extra-class"><pre class="language-css"><code> <span class="token property">-webkit-transform</span><span class="token punctuation">:</span><span class="token function">rotate</span><span class="token punctuation">(</span>-3deg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*为Chrome/Safari*/</span> 
 <span class="token property">-moz-transform</span><span class="token punctuation">:</span><span class="token function">rotate</span><span class="token punctuation">(</span>-3deg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*为Firefox*/</span> 
 <span class="token property">-ms-transform</span><span class="token punctuation">:</span><span class="token function">rotate</span><span class="token punctuation">(</span>-3deg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*为IE*/</span> 
 <span class="token property">-o-transform</span><span class="token punctuation">:</span><span class="token function">rotate</span><span class="token punctuation">(</span>-3deg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*为Opera*/</span> 
 <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">rotate</span><span class="token punctuation">(</span>-3deg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="css-hack"><a href="#css-hack" class="header-anchor">#</a> <strong>CSS hack</strong></h3> <p>有时我们需要针对不同的浏览器或不同版本写特定的CSS样式，这种针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack，写法大致归纳为3种：条件hack、属性级hack、选择符级hack。</p> <h3 id="自动化插件"><a href="#自动化插件" class="header-anchor">#</a> <strong>自动化插件</strong></h3> <ul><li>Autoprefixer是一款自动管理浏览器前缀的插件，它可以解析CSS文件并且添加浏览器前缀到CSS内容里，使用Can I Use（caniuse网站）的数据来决定哪些前缀是需要的。</li> <li>把Autoprefixer添加到资源构建工具（例如Grunt）后，可以完全忘记有关CSS前缀的东西，只需按照最新的W3C规范来正常书写CSS即可。如果项目需要支持旧版浏览器，可修改browsers参数设置 。</li> <li>目前webpack、gulp、grunt都有相应的插件，别再让CSS兼容性浪费你的时间。</li></ul> <h3 id="常见的css兼容性问题有哪些"><a href="#常见的css兼容性问题有哪些" class="header-anchor">#</a> <strong>常见的CSS兼容性问题有哪些</strong></h3> <ul><li>不同浏览器的标签默认的padding/margin不同，通过初始化css样式可以解决    *{ margin:0;padding:0px;  }</li> <li>IE6双边距BUG</li> <li>设置较小高度标签（一般小于10px）在IE6,IE7中高度超出自己设置的高度 ，通过设置overflow:hidden;或者设置行高line-height小于你设置的高度</li> <li>IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性</li> <li>Chrome中文界面下默认会将小于12px的文本强制为12px    通过加入css属性 -webkit-text-size-adjust：none;可以解决，或者使用transform中的缩放属性</li> <li>超链接访问过后hover样式就不出现，因为被点击访问过的超链接样式不再具有hover和active了 ，解决方法是改变css属性的排列属性：L-V-H-A    a:link{} → a:visited{} → a:hover{} → a:active{}</li> <li>IE下，event对象有x,y属性，但是没有pageX，pageY属性，但没有x，y属性    解决方式：通过条件- png24位的图片在IE6浏览器上出现背景，解决方案是做出PNG8</li></ul> <h2 id="css优化及性能提升"><a href="#css优化及性能提升" class="header-anchor">#</a> CSS优化及性能提升</h2> <ul><li>将css文件放在页面最上面，多个css可合并，并尽量减少http请求</li> <li>避免过渡约束，避免使用后代选择符，链式选择符，多种类型选择符</li> <li>避免不必要的命名空间，避免不必要的重复样式，移除空的css规则</li> <li>使用具有语义的名字，使用紧凑的语法</li> <li>避免使用 !important</li> <li>尽可能地精简规则，尽可能合并不同类的重复规则，修复解析错误</li> <li>正确使用display属性
<ul><li>inline后不应该使用width、height、margin、padding以及float</li> <li>inline-block后不应该使用float；block后不应该使用vertical-align</li></ul></li> <li>不滥用浮动，遵守盒模型规则</li> <li>不滥用web字体，不声明过多font-size，不重复定义h1-h6，不给h1-h6定义过多样式</li> <li>值为0时不需要任何单位</li> <li>标准化各种浏览器前缀</li></ul> <h2 id="web标准以及w3c"><a href="#web标准以及w3c" class="header-anchor">#</a> WEB标准以及W3C</h2> <h3 id="对于结构的要求"><a href="#对于结构的要求" class="header-anchor">#</a> 对于结构的要求：</h3> <p>规范的标签可以提高搜索引擎对页面的抓取效率，对SEO很有帮助</p> <ul><li>标签要闭合</li> <li>标签字母小写</li> <li>标签不允许随意嵌套</li></ul> <h3 id="对于css和js来说"><a href="#对于css和js来说" class="header-anchor">#</a> 对于CSS和JS来说：</h3> <ul><li>尽量使用外链CSS样式表和JS脚本。同时结构，表现和行为分为三块，符合规范。此外，还得提高页面渲染速度，提高用户体验。</li> <li>尽量少用行内样式，保证结构和表现分离。标签的id和class等的属性命名要做到见文知意，标签越少，加载越快，用户体验就会越高。同时代码方面也会更易于维护，便于改版。</li> <li>不需要变动内容，便可一同打印版本而不需要复制内容，提高网站易用性。</li></ul> <h2 id="问几个问题"><a href="#问几个问题" class="header-anchor">#</a> 问几个问题</h2> <h3 id="q1-当position跟display、overflow、float这些特性相互叠加后会出现什么情况"><a href="#q1-当position跟display、overflow、float这些特性相互叠加后会出现什么情况" class="header-anchor">#</a> Q1:  当position跟display、overflow、float这些特性相互叠加后会出现什么情况？</h3> <ul><li>display：规定元素应该生成的框的类型（子元素的排序方式）</li> <li>position：规定元素的定位类型</li> <li>float：定义元素在哪个方向浮动</li> <li>其中，position:absolute / fixed 优先级最高，当position设置为absolute或者fixed时，float失效，display需要调整，float / absolute定位的元素，只能是块元素或表单（block / table）</li></ul> <h3 id="q2-display-none-与-visibility-hidden-的区别是什么"><a href="#q2-display-none-与-visibility-hidden-的区别是什么" class="header-anchor">#</a> Q2：display:none 与 visibility:hidden 的区别是什么？</h3> <ul><li>display:none 隐藏对应的元素，在文档布局中不再分配空间（导致重排）</li> <li>visibility:hidden 隐藏对应的元素，在档布局中保留原来的空间（导致重绘）</li> <li>前者会使元素及其后代全部隐藏；后者具有继承性，子代会保持 hidden 的状态，但也可以单独设置为 visibility: visible 进行显示。</li></ul> <h3 id="q3-border-none-与border-0-有什么区别"><a href="#q3-border-none-与border-0-有什么区别" class="header-anchor">#</a> Q3：border:none;与border:0;有什么区别？</h3> <p><strong>性能差异：</strong></p> <ul><li>{border：0;}: 把border设置为0像素，虽然在页面上看不到，但是按border默认值理解，浏览器依然对border-width/border-color进行了渲染，即已经占用内存值；</li> <li>{border：none；}被理解为border-style:none。boder:0;比border:none多渲染了一个border-width:0,也就是为什么border:none的性能要比border:0高；</li></ul> <p><strong>兼容性差异：</strong></p> <ul><li>{border:none;}当border为“none”时似乎对IE6/7无效边框依然存在当border为“0”时，感觉比“none”更有效，所有浏览器都一致把边框隐藏。</li></ul> <h3 id="q4-px-em-rem-有什么区别"><a href="#q4-px-em-rem-有什么区别" class="header-anchor">#</a> Q4：px | em| REM 有什么区别?</h3> <p><strong>PX</strong>
px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。
<strong>EM</strong>
em的值并不是固定的， em会继承父级元素的字体大小。（浏览器body中1em=16px）</p> <ul><li>body选择器中声明Font-size=62.5%；</li> <li>将你的原来的px数值除以10，然后换上em作为单位；</li> <li>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</li></ul> <p><strong>REM（css3新增）</strong>
使用rem相对的只是HTML根元素。集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。
<strong>EX（不推荐）</strong></p> <ul><li>ex 是一个相对长度单位，1ex 被定义为一种给定字体的小写字母 “x” 的高度。因此，这个值会随字体的不同而变化。</li> <li>然而，很多浏览器都没有内置 ex 高度值，只是简单的取 em 的值，再取其一半作为 ex 的值。所以，一般不推荐使用 ex 这个长度单位。 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</li></ul> <h3 id="q5-视口单位-vw、vh、vmin、vmax"><a href="#q5-视口单位-vw、vh、vmin、vmax" class="header-anchor">#</a> Q5：视口单位 vw、vh、vmin、vmax</h3> <ul><li><strong>vw</strong> 视口宽度的1/100。</li> <li><strong>vh</strong>  视口高度的1/100。</li> <li><strong>vmin</strong>  vw 和 vh 中的最小值。</li> <li><strong>vmax</strong> vw 和 vh 中的最大值。</li></ul> <h3 id="q6-rgba-与-opacity-在透明效果上有什么区别"><a href="#q6-rgba-与-opacity-在透明效果上有什么区别" class="header-anchor">#</a> Q6：RGBA() 与 opacity 在透明效果上有什么区别？</h3> <ul><li>opacity 作用于元素，以及元素内的所有内容的透明度</li> <li>rgba() 只作用于元素的颜色或者背景色（设置rgba透明的元素的子元素不会继承透明效果）</li></ul> <h3 id="q7-png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下-分别什么时候用。有没有了解过webp"><a href="#q7-png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下-分别什么时候用。有没有了解过webp" class="header-anchor">#</a> Q7：png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3> <ul><li><strong>png</strong>便携式网络图片（Portable Network Graphics）,是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。 大多数地方都可以用。</li> <li><strong>jpg</strong>是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li> <li><strong>gif</strong>是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</li> <li><strong>bmp</strong>的优点： 高质量图片；缺点： 体积太大； 适用场景： windows桌面壁纸；</li> <li><strong>webp</strong>格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li></ul> <h3 id="q8-隐藏或者透明元素的方法"><a href="#q8-隐藏或者透明元素的方法" class="header-anchor">#</a> Q8：隐藏或者透明元素的方法？</h3> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> //1透明度为 0，整体都看不见了； 
<span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> //2这个和上边类似； 
<span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> //3消失，不占用位置； 
<span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0.2<span class="token punctuation">)</span><span class="token punctuation">;</span> //4只是背景色透明
</code></pre></div><h3 id="q9-css-sprites是什么-如何使用"><a href="#q9-css-sprites是什么-如何使用" class="header-anchor">#</a> Q9：css sprites是什么？如何使用？</h3> <ul><li>CSS sprites（雪碧）的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。</li> <li>该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非<img src="" alt="img">标签。</li></ul> <h3 id="q10-什么是渐进增强和优雅降级"><a href="#q10-什么是渐进增强和优雅降级" class="header-anchor">#</a> Q10：什么是渐进增强和优雅降级？</h3> <p><strong>渐进增强</strong></p> <ul><li>是指从最基本的可用性出发，在保证站点页面在低级浏览器中 的可用性和可访问性的基础上，逐步增加功能及提高用户体验。</li> <li>本质上讲，我们日常的一些开发习惯，例如首先使用标记语言编写页面，然后通过样式表来控制页面 样式等，都属于渐进增强的概念</li> <li>其他更为明显的行为包括使用HTML5、CSS3等新技术，针对高级浏览器为页面提高用户体验的丰富程度。</li></ul> <p><strong>优雅降级</strong></p> <ul><li>是指首先使用最新的技术面向高级浏览器构建最强的功能及用户体验，然后针对低级浏览器的限制，逐步衰减那些无法被支持的功能及体验。</li> <li>在我们日常的开 发中，一个典型的平稳退化的例子就是首先针对Chrome编写页面代码，然后修复IE中的异常或针对IE去除那些无法被实现的功能特色</li></ul> <p><strong>所以</strong></p> <ul><li>这两个概念方法其实早已并存在我们的日常开发工作中了，只是“渐进增强”与“优雅降级”这样的措辞是近些年才开始被普及。</li> <li>在我们眼下的HTML5与 CSS3实战中，这两个概念就尤其重要了，怎样保证使用不断变化的新技术来构建在主流浏览器下都具有基本可用性的站点，并针对高级浏览器进行体验提升，是我们在开发过程中需要明确的思路</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/webframe/css/" class="prev router-link-active">目录</a></span> <span class="next"><a href="/webframe/css/cssLayout.html">[css布局]</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.31678b28.js" defer></script><script src="/assets/js/2.62c74a10.js" defer></script><script src="/assets/js/19.a9091bf9.js" defer></script><script src="/assets/js/6.a591d526.js" defer></script>
  </body>
</html>
