<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTML 常见面试题 | 等风来</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="shortcut icon" href="/favicon.ico" type="iamge/x-icon">
    <meta name="description" content="听云白等风来,观雨落待花开">
    <meta name="keywords" content="等风来 前端 公众号 koala 前端文章">
    
    <link rel="preload" href="/assets/css/0.styles.d264b4b4.css" as="style"><link rel="preload" href="/assets/js/app.31678b28.js" as="script"><link rel="preload" href="/assets/js/2.62c74a10.js" as="script"><link rel="preload" href="/assets/js/34.7bd49029.js" as="script"><link rel="preload" href="/assets/js/6.a591d526.js" as="script"><link rel="prefetch" href="/assets/js/10.5f4205f9.js"><link rel="prefetch" href="/assets/js/11.525d008d.js"><link rel="prefetch" href="/assets/js/12.3ed2365b.js"><link rel="prefetch" href="/assets/js/13.8c53fe14.js"><link rel="prefetch" href="/assets/js/14.be26c194.js"><link rel="prefetch" href="/assets/js/15.57467872.js"><link rel="prefetch" href="/assets/js/16.05920caa.js"><link rel="prefetch" href="/assets/js/17.8c668bf9.js"><link rel="prefetch" href="/assets/js/18.e11e7c51.js"><link rel="prefetch" href="/assets/js/19.a9091bf9.js"><link rel="prefetch" href="/assets/js/20.a6246bd5.js"><link rel="prefetch" href="/assets/js/21.39b844ad.js"><link rel="prefetch" href="/assets/js/22.1fc1566e.js"><link rel="prefetch" href="/assets/js/23.6d7cef02.js"><link rel="prefetch" href="/assets/js/24.0f79d0d3.js"><link rel="prefetch" href="/assets/js/25.327f097e.js"><link rel="prefetch" href="/assets/js/26.e9d9f961.js"><link rel="prefetch" href="/assets/js/27.077644c5.js"><link rel="prefetch" href="/assets/js/28.64d65ea5.js"><link rel="prefetch" href="/assets/js/29.0e6c2921.js"><link rel="prefetch" href="/assets/js/3.bd6e5b2c.js"><link rel="prefetch" href="/assets/js/30.9ffdc77b.js"><link rel="prefetch" href="/assets/js/31.b32fb676.js"><link rel="prefetch" href="/assets/js/32.2ce6f6bf.js"><link rel="prefetch" href="/assets/js/33.778e841e.js"><link rel="prefetch" href="/assets/js/35.1855c4f8.js"><link rel="prefetch" href="/assets/js/4.0f32a644.js"><link rel="prefetch" href="/assets/js/5.6d92e1ac.js"><link rel="prefetch" href="/assets/js/7.277ec606.js"><link rel="prefetch" href="/assets/js/8.ca84de0e.js"><link rel="prefetch" href="/assets/js/9.93419cdf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d264b4b4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">等风来</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/node/" class="nav-link">node</a></div><div class="nav-item"><a href="/webframe/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/database/" class="nav-link">数据库</a></div> <a href="https://github.com/fanshouzhi/fanshouzhi.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/node/" class="nav-link">node</a></div><div class="nav-item"><a href="/webframe/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/database/" class="nav-link">数据库</a></div> <a href="https://github.com/fanshouzhi/fanshouzhi.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <div class="my_introduce" style="padding-left:1rem;"><div class="introduce_component" data-v-7e42bc5a><img src="/images/small.png" alt data-v-7e42bc5a> <div class="intro_content" data-v-7e42bc5a><h3 data-v-7e42bc5a>千里马常有，而伯乐不常有</h3> <p data-v-7e42bc5a> 学习成长之路必将孤独</p></div></div></div> <ul class="sidebar-links"><li><a href="/webframe/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="html-常见面试题"><a href="#html-常见面试题" class="header-anchor">#</a> HTML 常见面试题</h1> <h2 id="块级元素和行内-内联元素"><a href="#块级元素和行内-内联元素" class="header-anchor">#</a> 块级元素和行内/内联元素</h2> <table><thead><tr><th></th> <th>块级元素</th> <th>行内元素</th></tr></thead> <tbody><tr><td>特点</td> <td>块级元素占据一行的空间</td> <td>行内元素只占据内容的宽度</td></tr> <tr><td>宽高</td> <td>可以设置 <code>width</code> 和 <code>height</code>，<code>width</code> 默认 100%</td> <td>设置 <code>width</code> 和 <code>height</code> 无效</td></tr> <tr><td>边距</td> <td>可以设置 <code>margin</code> 和 <code>padding</code></td> <td><code>margin</code> 和 <code>padding</code> 只能设置水平方向，不能设置垂直方向</td></tr> <tr><td>常见标签</td> <td><code>&lt;div&gt; &lt;p&gt; &lt;h1&gt; &lt;form&gt; &lt;ol&gt; &lt;ul&gt; &lt;li&gt; &lt;audio&gt; &lt;video&gt; &lt;canvas&gt;</code></td> <td><code>&lt;span&gt; &lt;a&gt; &lt;img&gt; &lt;button&gt; &lt;input&gt; &lt;label&gt; &lt;br&gt; &lt;i&gt; &lt;strong&gt;</code></td></tr></tbody></table> <h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="header-anchor">#</a> src 和 href 的区别</h2> <p><code>src</code> 和 <code>href</code> 都可以加载外部资源，区别在于：</p> <ul><li><code>src</code>：常用于 <code>&lt;script&gt;</code> 标签，会加载和解析资源，阻塞页面的渲染。</li> <li><code>href</code>：常用于 <code>&lt;link&gt;</code> 和 <code>&lt;a&gt;</code> 标签，会并行下载资源，不会阻塞当前文档的加载。</li></ul> <h2 id="为什么通常把-script-标签放在-body-的底部"><a href="#为什么通常把-script-标签放在-body-的底部" class="header-anchor">#</a> 为什么通常把 <code>&lt;script&gt;</code> 标签放在 <code>&lt;body&gt;</code> 的底部？</h2> <p>如果把 JS 文件放在 <code>&lt;head&gt;</code> 里，会阻塞页面的渲染，页面渲染需要等到 JS 文件下载、解析后，期间页面会呈现空白。</p> <h2 id="html5-新特性"><a href="#html5-新特性" class="header-anchor">#</a> HTML5 新特性</h2> <ol><li>新增语义化标签：<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code> 等。</li> <li>新增音频和视频标签：<code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code>。</li> <li>本地化存储：<code>localStorage</code> 和 <code>sessionStorage</code>。</li> <li>支持 canvas。</li> <li>支持 web socket。</li> <li>history API：<code>go</code>、<code>forward</code>、<code>back</code>、<code>pushstate</code>。</li></ol> <h2 id="b-标签和-strong-标签的区别、i-标签和-em-标签的区别"><a href="#b-标签和-strong-标签的区别、i-标签和-em-标签的区别" class="header-anchor">#</a> b 标签和 strong 标签的区别、i 标签和 em 标签的区别</h2> <ul><li><code>&lt;strong&gt;</code> 是语义化标签，表示加重语气，而 <code>&lt;b&gt;</code> 标签只用于加粗效果，不过浏览器一般都会将 <code>&lt;strong&gt;</code> 的默认样式设为加粗。</li> <li><code>&lt;em&gt;</code> 是语义化标签，表示强调语气，而 <code>&lt;i&gt;</code> 标签只用于斜体效果，不过浏览器一般都会将 <code>&lt;em&gt;</code> 的默认样式设置为斜体。</li></ul> <h2 id="html5-语义化标签优点"><a href="#html5-语义化标签优点" class="header-anchor">#</a> HTML5 语义化标签优点</h2> <ol><li>增加代码可读性和可维护性；</li> <li>有利于 SEO；</li> <li>对无障碍阅读友好，例如屏幕阅读器可以更好地读取页面信息。</li></ol> <h1 id="css-常见面试题"><a href="#css-常见面试题" class="header-anchor">#</a> CSS 常见面试题</h1> <h2 id="css-选择器及优先级"><a href="#css-选择器及优先级" class="header-anchor">#</a> CSS 选择器及优先级</h2> <table><thead><tr><th>选择器</th> <th>格式</th> <th>权重值</th></tr></thead> <tbody><tr><td>id 选择器</td> <td><code>#id</code></td> <td>100</td></tr> <tr><td>类名选择器</td> <td><code>.classname</code></td> <td>10</td></tr> <tr><td>属性选择器</td> <td><code>input[type=&quot;text&quot;]</code></td> <td>10</td></tr> <tr><td>伪类选择器</td> <td><code>ul:first-child</code></td> <td>10</td></tr> <tr><td>标签选择器</td> <td><code>div</code></td> <td>1</td></tr> <tr><td>伪元素选择器</td> <td><code>a::after</code></td> <td>1</td></tr> <tr><td>后代选择器</td> <td><code>ul li</code></td> <td>0</td></tr> <tr><td>子选择器</td> <td><code>ul &gt; li</code></td> <td>0</td></tr> <tr><td>相邻兄弟选择器</td> <td><code>label + input</code></td> <td>0</td></tr> <tr><td>通配符选择器</td> <td><code>*</code></td> <td>0</td></tr></tbody></table> <p>注意：</p> <ul><li>权重值大的选择器优先级高；</li> <li>内联样式的权重值为 1000；</li> <li><code>!important</code> 的优先级最高；</li> <li>如果优先级相同，则最后的样式生效。</li></ul> <h2 id="常见的居中方式"><a href="#常见的居中方式" class="header-anchor">#</a> 常见的居中方式</h2> <ol><li><p><code>text-align: center</code> （文本水平居中）</p></li> <li><p><code>margin: 0 auto</code>（水平居中）</p></li> <li><p><code>line-height: 1em</code>（单行文本垂直居中）</p></li> <li><p>绝对定位：<code>position: absolute; top: 0; left: 0; transform: translate(-50%, -50%)</code></p></li> <li><p>弹性布局：<code>display: flex; justify-content: center; align-items: center</code></p></li></ol> <h2 id="常见隐藏元素的方式"><a href="#常见隐藏元素的方式" class="header-anchor">#</a> 常见隐藏元素的方式</h2> <ul><li><code>display: none</code>：元素会从文档树中删除，不会占据空间。</li> <li><code>visibility: hidden</code>：元素仍然占据空间，但绑定的事件不生效。</li> <li><code>opacity: 0</code>：元素的不透明度设为0，元素仍然占据空间且绑定的事件仍然生效。</li> <li><code>position: absolute</code>：通过绝对定位，将元素设置到可视区域外。</li> <li><code>z-index: -1</code>：通过其他元素将其盖住，来实现隐藏效果。</li></ul> <h2 id="transition-和-animation-的区别"><a href="#transition-和-animation-的区别" class="header-anchor">#</a> transition 和 animation 的区别</h2> <ul><li><code>transition</code>：用于定义 CSS 属性变化的效果，只涉及初始帧和结束帧，通常需要某个事件才能触发，例如点击（<code>:active</code>）、鼠标滑过（<code>:hover</code>）、聚焦（<code>:focus</code>）等。</li> <li><code>animation</code>：可以更加灵活地定义动画，可以通过 <code>@keyframes</code> 定义多个动画帧，可以循环执行，不要事件就可以触发。</li></ul> <h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="header-anchor">#</a> 伪类和伪元素</h2> <ul><li>伪类：用于设置元素在特定状态下的样式。常见的伪类有：<code>:hover</code>、<code>:active</code>、<code>:visited</code>、<code>:first-child</code> 等。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">a:hover</span> <span class="token punctuation">{</span>
  <span class="token property">text-decoration</span><span class="token punctuation">:</span> underline<span class="token punctuation">;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>伪元素：用于设置元素特定部分的内容和样式。常见的伪元素有：</li></ul> <table><thead><tr><th>伪元素</th> <th>作用</th></tr></thead> <tbody><tr><td><code>::before</code></td> <td>在元素前面额外插入内容并设置样式</td></tr> <tr><td><code>::after</code></td> <td>在元素后面额外插入内容并设置样式</td></tr> <tr><td><code>::first-letter</code></td> <td>设置块级元素第一行第一个字符的样式</td></tr> <tr><td><code>::selection</code></td> <td>设置选中文本样式</td></tr></tbody></table> <h2 id="盒模型"><a href="#盒模型" class="header-anchor">#</a> 盒模型</h2> <p>盒模型由 <code>margin</code>、<code>border</code>、<code>padding</code> 和 <code>content</code> 四部分构成。</p> <ul><li>标准盒模型（默认）：<code>width</code> 和 <code>height</code> 范围只包含 <code>content</code>。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
  <span class="token property">box-sizing</span><span class="token punctuation">:</span> content-box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>IE盒模型（怪异盒模型）：<code>width</code> 和 <code>height</code> 的范围包含 <code>content</code>、<code>padding</code> 和 <code>border</code>。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="分辨率、像素比和视口"><a href="#分辨率、像素比和视口" class="header-anchor">#</a> 分辨率、像素比和视口</h2> <ul><li>物理分辨率：屏幕的实际分辨率，常见的有 1920*1080、2560*1440 等。</li> <li>逻辑分辨率和设备像素比：随着移动设备的屏幕分辨率越来越高，如果1个像素点只渲染1个像素点对应的内容，那么图片和文字就会显得非常小，为了解决这个问题，浏览器的<strong>逻辑分辨率</strong>就诞生了。浏览器通过一个倍率降低分辨率，达到人眼能够看到的更好的效果。例如一台手机的<strong>物理分辨率</strong>是 1920*1080，浏览器以<strong>逻辑分辨率</strong> 640*320 来渲染页面，也就是3个物理像素点渲染1个像素的内容，这个比率被称为<strong>设备像素比</strong>。浏览器的<strong>设备像素比</strong>可以通过 <code>window.devicePixelRatio</code> 来获取。</li> <li>视觉视口：指用户通过屏幕可以看到的区域，一般等于浏览器窗口大小。</li> <li>布局视口：指页面布局的基准窗口，一般 PC 端浏览器的布局视口与浏览器窗口大小相等，但在移动端，布局视口有一个默认值，约为 <code>964px</code>（布局视口大小可以通过 <code>document.documentElement.clientWidth / clientHeight</code> 来获取），这样用户需要左右滚动和缩放才能看到页面的完整内容。为了解决上面的问题，我们通常通过 <code>&lt;meta&gt;</code> 标签设置浏览器的布局视口大小等于视觉视口的大小。</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><h2 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="header-anchor">#</a> 渐进增强和优雅降级</h2> <ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li> <li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul> <h2 id="重排和重绘"><a href="#重排和重绘" class="header-anchor">#</a> 重排和重绘</h2> <ul><li><strong>重排</strong>：当页面元素的尺寸、结构等发生变化时，浏览器会重写渲染部分或者整个文档，由于浏览器渲染页面是基于流式布局的，所以会导致周围的元素重新排列。常见的会引起重排的操作有：元素的尺寸、位置、内容、字体等发生变化，触发 CSS 伪类，添加或删除元素等。</li> <li><strong>重绘</strong>：当元素的样式发生变化时，浏览器会对其重新绘制，但不会影响其他元素的位置。<strong>重排一定会触发重绘，重绘时不一定会重排</strong>。</li></ul> <h2 id="css-性能优化"><a href="#css-性能优化" class="header-anchor">#</a> CSS 性能优化</h2> <ol><li>CSS 代码压缩；</li> <li>使用类名选择器代替标签选择器；</li> <li>避免使用通配符选择器（<code>*</code>）；</li> <li>后代选择器的层级不要超过三层；</li> <li>避免使用 <code>@import</code>；</li> <li>使用 <code>transition</code> 和 <code>animation</code> 代替 JS 实现简单的动画效果。</li></ol> <h2 id="scss-和-less-等-css-扩展语言有哪些特性"><a href="#scss-和-less-等-css-扩展语言有哪些特性" class="header-anchor">#</a> SCSS 和 Less 等 CSS 扩展语言有哪些特性</h2> <p>变量、嵌套、混合、导入等。</p> <h1 id="js-常见面试题"><a href="#js-常见面试题" class="header-anchor">#</a> JS 常见面试题</h1> <h2 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h2> <p><strong>文档对象模型</strong>（Document Object Model）是一个应用编程接口，网页可以抽象为一颗 DOM 树，开发者可以通过 DOM 树控制网页的内容和结构。</p> <h2 id="js-基本数据类型和引用数据类型"><a href="#js-基本数据类型和引用数据类型" class="header-anchor">#</a> JS 基本数据类型和引用数据类型</h2> <ul><li>基本数据类型：Boolean、Number、String、Undefined、Null、Symbol、BigInt</li> <li>引用数据类型：Object（Function、Date、RegExp、Array、Map、Set...）</li></ul> <h2 id="undefined-和-null-区别"><a href="#undefined-和-null-区别" class="header-anchor">#</a> undefined 和 null 区别</h2> <ul><li>undefined：变量未声明；变量声明但未初始化</li> <li>null：空对象指针；建议使用 null 初始化将来要保存对象的变量</li></ul> <h2 id="var、let-和-const-声明"><a href="#var、let-和-const-声明" class="header-anchor">#</a> var、let  和 const 声明</h2> <ol><li><p><code>var</code> 声明的是函数作用域，<code>let</code> 声明的是块级作用域。</p></li> <li><p><code>var</code> 声明的变量会自动提升到函数作用域顶部，例如可以先使用后声明；而 <code>let</code> 声明的变量不会在作用域中被提升，即需要先声明再使用。</p></li> <li><p><code>const</code> 与 <code>let</code> 行为基本一致，只不过 <code>const</code> 声明的是常量，不允许被修改；如果 <code>const</code> 声明的变量是一个对象的引用，则对象内部可以被修改，只不过变量的引用不能修改。</p></li></ol> <h2 id="位操作符"><a href="#位操作符" class="header-anchor">#</a> 位操作符</h2> <table><thead><tr><th>符号</th> <th>名称</th> <th>操作</th></tr></thead> <tbody><tr><td><code>&amp;</code></td> <td>与</td> <td>两位都是1时返回1，否则为0</td></tr> <tr><td><code>|</code></td> <td>或</td> <td>有一位是1时返回1，两位都是0时返回0</td></tr> <tr><td><code>~</code></td> <td>非</td> <td>取反操作，最终数值取反减1</td></tr> <tr><td><code>^</code></td> <td>异或</td> <td>相同为0，不同为1</td></tr> <tr><td><code>&lt;&lt;</code></td> <td>左移</td> <td>所有数值左移，低位补0，保留符号位</td></tr> <tr><td><code>&gt;&gt;</code></td> <td>有符号右移</td> <td>所有数值右移，高位用符号位补充</td></tr> <tr><td><code>&gt;&gt;&gt;</code></td> <td>无符号右移</td> <td>所有数位右移，高位补0</td></tr></tbody></table> <h2 id="操作符的判断及强制类型转换规则"><a href="#操作符的判断及强制类型转换规则" class="header-anchor">#</a> == 操作符的判断及强制类型转换规则</h2> <p>若两个操作数类型相同，则比较值是否相等；若两者类型不同，则会进行<strong>强制类型转换</strong>：</p> <ol><li>如果两者分别是 <code>null</code> 和 <code>undefined</code>，则返回 <code>true</code>；</li> <li>如果其中一个操作数是 <code>boolean</code> 类型，则转化为 <code>number</code>（<code>true</code> 转化为 <code>1</code>，<code>false</code> 转化为 <code>0</code>）；</li> <li>如果其中一个操作数是 <code>string</code> 类型，另一个是 <code>number</code> 类型，则会调用 <code>Number()</code> 方法将 <code>string</code> 转化为 <code>number</code>（如果包含非数字字符，则转化为 <code>NaN</code>，如果为空字符串，则转化为 <code>0</code>）；</li> <li>如果其中一个操作数是 <code>object</code>，另一个是基本数据类型，则调用对象的 <code>valueOf()</code> 转化为基本数据类型；</li> <li>如果两个操作数都是 <code>object</code>，则比较引用的是否为同一个对象；</li> <li>如果任意一个操作符是 <code>NaN</code>，则返回 <code>false</code>（<code>NaN</code> 和 <code>NaN</code> 不相等）。</li></ol> <h2 id="和"><a href="#和" class="header-anchor">#</a> == 和 ===</h2> <p><code>==</code> （不全等）不保证两个操作数的类型和值都相等，只表示类型转换后的值相等。</p> <p><code>===</code> （全等）表示两个操作数的类型和值都相等。</p> <h2 id="如何令-a-1-a-2-a-3-成立"><a href="#如何令-a-1-a-2-a-3-成立" class="header-anchor">#</a> 如何令 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 成立</h2> <ul><li>重写对象的 <code>valueOf()</code> 方法：使用 <code>==</code> 比较时，如果一个操作数是对象，另一个操作数是基本类型，就会调用对象的 <code>valueOf()</code> 方法。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">i</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>使用 <code>Object.defineProperty()</code> 在当前上下文定义 <code>a</code> 属性，并修改 <code>get()</code> 函数：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> _a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> _a<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="箭头函数和普通函数"><a href="#箭头函数和普通函数" class="header-anchor">#</a> 箭头函数和普通函数</h2> <p>箭头函数相比于普通函数，有以下特点：</p> <ol><li>不能作为构造函数</li> <li>不能使用 <code>arguments</code> 对象，需要使用剩余参数代替</li> <li>普通函数 <code>this</code> 指向调用函数的上下文（谁调用了函数，<code>this</code> 就指向谁），是可变的；箭头函数的 <code>this</code> 指向函数定义时的上下文，是固定的</li></ol> <h2 id="this-的指向"><a href="#this-的指向" class="header-anchor">#</a> this 的指向</h2> <ul><li>普通函数的 <code>this</code> 指向调用函数的上下文对象，也就是谁调用这个函数， <code>this</code> 就指向谁，如果直接调用，则指向全局对象，这个值只有在函数执行时才能确定。</li> <li>通过 <code>new</code> 实例化对象，构造函数的 <code>this</code> 指向实例。</li> <li>可以通过函数的 <code>apply()</code>、<code>call()</code> 和 <code>bind()</code> 方法改变函数 <code>this</code> 的指向。</li></ul> <h2 id="foreach-方法可以退出循环吗"><a href="#foreach-方法可以退出循环吗" class="header-anchor">#</a> forEach() 方法可以退出循环吗？</h2> <p>除抛出异常之外，没有其他方法可以停止或中断循环（<code>continue/break</code> 无效，<code>return</code> 等同于 <code>break</code>）。当你需要通过抛出异常来退出循环时，说明该场景不适合使用 <code>forEach()</code> 。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>闭包指的是<strong>引用了另一个函数作用域中变量的函数</strong>，通常是在嵌套函数中，当内部函数引用了外部函数的变量，即使外部函数执行完，作用域链被销毁，内部函数还是保留其活动对象，这些变量仍然保留在内存中，这就造成了内存泄漏，采用引用计数垃圾回收机制的旧浏览器就无法进行垃圾回收。</p> <h2 id="闭包的作用"><a href="#闭包的作用" class="header-anchor">#</a> 闭包的作用</h2> <ol><li>创建私有变量</li> <li>使函数中的变量继续保存在内存中</li></ol> <h2 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h2> <p>当执行一个函数时，我们称进入了一个执行上下文（或者叫执行环境），JS 通过执行上下文栈来管理上下文，可以分为三个阶段：</p> <ol><li><strong>创建阶段</strong>：当调用函数时，会为该函数创建一个执行上下文并压入栈中。JS 一开始在全局环境执行时会创建全局上下文并压入栈中。</li> <li><strong>执行阶段</strong>：JS 会先执行上下文栈顶的函数。</li> <li><strong>回收阶段</strong>：当函数执行完后，会从上下文栈中弹出并执行下一个函数，该函数作用域中创建的变量也会等待垃圾回收。当所有代码执行完后，全局上下文也会弹出。</li></ol> <h2 id="变量对象和作用域链"><a href="#变量对象和作用域链" class="header-anchor">#</a> 变量对象和作用域链</h2> <ul><li><strong>变量对象</strong>：每个执行上下文都会有一个变量对象，用于保存当前上下文定义的变量和函数（一开始会添加通过函数声明定义的函数以及通过 <code>var</code> 声明的变量 ）。</li> <li><strong>作用域链</strong>：当执行上下文代码时，JS 会创建一个作用域链，用于决定上下文访问变量和函数的顺序。当前上下文的变量对象始终处于作用域链的最顶端，同时作用域链还会包含上一个上下文的变量对象，以此类推，直至全局上下文。当解析变量时，会通过变量的标识符从作用域链中进行查找，首先会从当前上下文的变量对象中查找，如果没有找到，会沿着作用域链往上一级上下文的变量对象里边查找，以此类推。由此可以看出，内部上下文可以通过作用域链访问外部上下文的变量，反之则不行；除此之外，内部上下文可以替换外部上下文中的同名变量。</li></ul> <h2 id="函数防抖和函数节流"><a href="#函数防抖和函数节流" class="header-anchor">#</a> 函数防抖和函数节流</h2> <p>函数防抖（debounce）和函数节流（throttle）通过控制函数一定时间内的执行次数，来避免某些函数频繁执行带来的性能损耗，常用于限制事件监听，如输入框联想，滚动监听等。</p> <ul><li>防抖：函数必须间隔特定时间才能执行，如果期间重复触发，就会重新计时</li> <li>节流：一定时间内，只会执行一次函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 防抖</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 节流</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="header-anchor">#</a> 栈内存和堆内存</h2> <ul><li><strong>栈内存空间</strong>：用栈作为数据结构在内存中所申请的空间。基本数据类型变量存储在栈内存中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。</li> <li><strong>堆内存空间</strong>：用堆作为数据结构在内存中所申请的空间。引用数据类型存储在堆内存中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。引用数据类型会在栈中存储一个指针，这个指针指向堆内存空间中该实体的起始地址。</li></ul> <h2 id="js-垃圾回收机制"><a href="#js-垃圾回收机制" class="header-anchor">#</a> JS 垃圾回收机制</h2> <p>JavaScript 垃圾回收程序每隔一个周期，就会判断哪些变量不再使用，然后释放它占用的内存。JS 垃圾回收机制一般分为两种：</p> <ul><li><strong>标记清理</strong>（mark-and-sweep）（常用）：当变量进入上下文，比如在函数内部声明一个变量时，这个变量就会被标记为存在上下文中；当变量离开上下文，例如函数执行完，该变量就会被标记为离开上下文，这样，下一次垃圾回收程序清理内存时，就会释放该变量的内存。</li> <li><strong>引用计数</strong>（reference counting）（旧版本浏览器）：当一个值被一个变量引用时，该值的引用数加 1，当引用该值的变量被其他值覆盖时，该值的引用数减 1，当引用数为 0 时，说明该值不需要被用得到，则内存可以被回收。这种回收机制有个弊端，当两个对象通过属性值<strong>循环引用</strong>时，它们的引用数都是 2，即使函数执行完，这两个对象不在作用域中时，这两个变量也不会被垃圾回收程序释放。</li></ul> <h2 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="header-anchor">#</a> 哪些情况会导致内存泄漏</h2> <ul><li><p><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p></li> <li><p><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p></li> <li><p><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</p></li> <li><p><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p></li></ul> <h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="header-anchor">#</a> 深拷贝和浅拷贝</h2> <ul><li><strong>浅拷贝</strong>：只复制引用地址，新旧对象共享相同的内存空间，修改新对象属性会影响原对象，常见的浅拷贝方法：扩展运算符、<code>Object.assign</code>、<code>Object.create</code>、<code>Array.protorype.slice</code> 和 <code>Array.prototype.concat</code></li> <li><strong>深拷贝</strong>：创建一个于原对象一模一样的新对象，新旧对象不共享内存空间，修改新对象属性不会影响原对象，常见的深拷贝方法：<code>lodash.cloneDeep</code>、<code>JSON.stringify</code> 以及手写递归方法</li></ul> <p>其中，使用 <code>JSON.stringify</code> 进行深拷贝的弊端：</p> <ol><li>不支持 undefined、symbol 和函数类型</li> <li>Date 类型会转化为字符串</li> <li>只能序列化可枚举的属性</li></ol> <h2 id="map-和-weakmap-区别"><a href="#map-和-weakmap-区别" class="header-anchor">#</a> Map 和 WeakMap 区别</h2> <ul><li>Map 的 key 可以是任意数据类型，WeakMap 的 key 必须是对象。</li> <li>Map 的 key 如果是对象，就相当于这个对象被引用，就不会被当做垃圾回收；WeakMap 的 key 不属于正式引用，不会阻止垃圾回收，也就是说，如果 key 没有其他引用，就会执行垃圾回收。</li> <li>因为 WeakMap 中的 key/value 任何时候都有可能被销毁，所以 WeakMap 本身不可迭代。</li></ul> <h2 id="js-设计模式"><a href="#js-设计模式" class="header-anchor">#</a> JS 设计模式</h2> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <p>工厂模式用于创建多个类似的对象，但是创建的对象不属于同一个类型（除了 <code>Object</code>）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tom</span>
</code></pre></div><h3 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h3> <p>构造函数模式解决了创建特定类型对象的问题，但是构造函数定义的方法，在每个实例上都会被创建一遍。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tom</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h3> <p>通过原型模式创建的属性和方法，所有实例都可以通过原型链查找访问到，也就是说是共享的。原型模式不能在创建实例时传递参数，除此之外，由于原型对象共享属性和方法，修改引用类型的原型属性时，会出现数据污染的问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Tom'</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tom</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="组合模式"><a href="#组合模式" class="header-anchor">#</a> 组合模式</h3> <p>组合模式通过构造函数模式定义实例属性，通过原型模式定义共享属性和方法，既可以通过构造函数传参，又可以通过原型共享节省内容。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tom</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="类"><a href="#类" class="header-anchor">#</a> 类</h3> <p>ES6 引入 <code>class</code> ，本质上是组合模式的语法糖。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Tom</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h2 id="通过-new-创建实例的过程"><a href="#通过-new-创建实例的过程" class="header-anchor">#</a> 通过 new 创建实例的过程</h2> <ol><li>在内存中创建新对象。</li> <li>新对象的原型指针指向构造函数的原型。</li> <li>构造函数内的 <code>this</code> 指向新对象。</li> <li>执行构造函数内部代码。</li> <li>如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。</li></ol> <h2 id="原型链的终点"><a href="#原型链的终点" class="header-anchor">#</a> 原型链的终点</h2> <p><code>Object</code> 是其他对象的基类，所以所有对象的原型链最终都会指向 <code>Object</code> ，而 <code>Object</code> 的原型对象是 <code>null</code>。</p> <h2 id="如何判断一个对象是某个类的实例"><a href="#如何判断一个对象是某个类的实例" class="header-anchor">#</a> 如何判断一个对象是某个类的实例</h2> <ol><li><code>instanceof</code>（判断构造函数的原型对象是否在实例的原型链上）</li> <li>判断对象的 <code>constructor</code> 属性是否为类的构造函数（不安全，因为 <code>constructor</code> 可能被修改）</li> <li>判断对象的原型指针是否指向类的原型</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="遍历对象属性的方法"><a href="#遍历对象属性的方法" class="header-anchor">#</a> 遍历对象属性的方法</h2> <ul><li><code>for-in</code>：遍历实例及其原型对象的所有可枚举属性。</li> <li><code>Object.keys()</code>：只返回实例本身的可枚举属性。</li> <li><code>Object.getOwnPropertyNames()</code>：返回实例及其原型对象的所有属性，包含不可枚举的（例如 <code>constructor</code>）。</li></ul> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h2> <p>代理（Proxy）是 ES6 新增的特性，可以对对象的读写等操作进行拦截：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'target'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">被读取，值为：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">被设置，旧值为：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，新值为：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'target2'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Proxy 的应用场景：隐藏属性、数据验证、函数参数验证、数据绑定（Vue）。</p> <h2 id="promise、async-await"><a href="#promise、async-await" class="header-anchor">#</a> Promise、async/await</h2> <ul><li><p><code>Promise</code> 是 ES6 增加的一种异步编程机制，可以解决“回调地狱”的问题。</p></li> <li><p><code>async/await</code> 是 ES2017 推出的 <code>Promise</code> 的语法糖，可以使用更加接近同步编程的方式处理异步代码。使用 <code>async</code> 声明的函数叫做异步函数，异步函数的返回值会被 <code>Promise.resolve</code> 包装成一个 <code>Promise</code> 对象。<code>await</code> 需要在异步函数中使用，<code>await</code> 可以暂停异步函数代码的执行，等待异步代码执行完，再执行其他代码。</p></li></ul> <h2 id="promise-all、promise-race、promise-any"><a href="#promise-all、promise-race、promise-any" class="header-anchor">#</a> Promise.all、Promise.race、Promise.any</h2> <ul><li><code>Promise.all()</code>：所有 <code>Promise</code> 都解决则返回一个解决值得数组，如果有 <code>Promise</code> 拒绝，则会返回第一个拒绝的状态值。</li> <li><code>Promise.race()</code>：会返回第一个解决或者拒绝的 <code>Promise</code>，这个方法也称为竞速方法。</li> <li><code>Promise.any()</code>：会返回第一个解决的 <code>Promise</code> 的结果，如果全部拒绝则返回失败结果。</li></ul> <h2 id="js-单线程"><a href="#js-单线程" class="header-anchor">#</a> JS 单线程</h2> <ul><li><strong>进程</strong>：资源分配的最小单位</li> <li><strong>线程</strong>：CPU 调度的最小单位</li></ul> <p>进程是火车，线程是车厢，线程在进程下运行，一个线程无法独立运行，一个进程可以包含多个线程（一辆火车可以有多个车厢）。进程要比线程消耗更多的计算机资源（加列火车比加节车厢更耗资源）。</p> <ul><li>JS 是单线程语言，执行完一个任务之后才能执行其他任务。</li> <li>浏览器内核是多线程。一些 I/O 操作、定时器和事件监听都是由浏览器提供的其它线程来完成的。</li></ul> <h2 id="js-事件循环和任务队列"><a href="#js-事件循环和任务队列" class="header-anchor">#</a> JS 事件循环和任务队列</h2> <p>JS 是单线程语言，事件循环是 JS 的执行机制，可以处理同步任务和异步任务。</p> <p>在一次事件循环中，遇到同步任务，立即执行，遇到异步任务，将其放到任务队列中，同步代码执行完之后，检查当前任务队列中是否有异步任务，如果有，则执行异步任务；如果没有，则继续执行同步任务。</p> <h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="header-anchor">#</a> 宏任务和微任务</h2> <p><strong>宏任务</strong>：script、计时器、网络请求、事件、文件读写</p> <p><strong>微任务</strong>：Promise</p> <p>异步任务可分为宏任务和微任务，这两者主要是执行顺序不同，每次执行完宏任务之后，先执行微任务队列里边的微任务，然后再执行下一个宏任务。</p> <p>一道经典面试题，写出以下代码的输出顺序：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 1 3 4 6 5 2</span>
</code></pre></div><p>首先，打印 1 是同步代码，直接执行；</p> <p>然后定时器是宏任务，放到宏任务队列中；</p> <p>然后 <code>Promise</code> 构造函数本身是同步代码，因此按顺序打印 3 和 4；</p> <p>然后 <code>Promise</code> 的 <code>then</code> 毁掉函数是微任务，放到微任务队列中；</p> <p>打印 6 是同步代码直接执行；</p> <p>当前宏任务执行完毕（script 本身就是一个宏任务），执行所有微任务，打印 5；</p> <p>执行下一个宏任务，打印 2。</p> <h2 id="js-模块化的发展"><a href="#js-模块化的发展" class="header-anchor">#</a> JS 模块化的发展</h2> <ol><li>引入多个 script 文件，需要手动管理文件加载顺序，而且无法避免变量污染的问题</li> <li>通过立即执行函数对代码进行封装</li> <li>Node 使用 CommonJS 规范来封装模块</li> <li>ES6 原生支持模块的导入导出</li></ol> <h2 id="es6-新特性-总"><a href="#es6-新特性-总" class="header-anchor">#</a> ES6 新特性（总）</h2> <ol><li>新增块级作用域及 <code>let</code> 和 <code>const</code> 声明</li> <li>解构赋值</li> <li>扩展运算符</li> <li>箭头函数</li> <li>新增数据结构：<code>Map</code>、<code>Set</code>、<code>WeakMap</code> 和 <code>WeakSet</code></li> <li>新增数据类型 <code>symbol</code></li> <li><code>Promise</code></li> <li><code>Proxy</code> 和 <code>Reflect</code></li> <li>类</li> <li>模块化</li></ol> <h1 id="前端笔试题"><a href="#前端笔试题" class="header-anchor">#</a> 前端笔试题</h1> <h2 id="手写-object-create-方法"><a href="#手写-object-create-方法" class="header-anchor">#</a> 手写 Object.create() 方法</h2> <p><code>Object.create()</code> 方法将传入的对象作为新对象的原型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> object<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="手写-instanceof"><a href="#手写-instanceof" class="header-anchor">#</a> 手写 instanceof</h2> <p><code>instanceof</code> 用于判断对象是否是构造函数的实例，原理是判断构造函数的原型对象是否在实例的原型链上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype <span class="token operator">===</span> object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span>prototype<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="手写-new"><a href="#手写-new" class="header-anchor">#</a> 手写 new</h2> <p>通过 <code>new</code> 创建实例包含以下过程：</p> <ol><li>为新对象分配内存</li> <li>新对象的原型指针指向构造函数的原型</li> <li><code>this</code> 指向新对象</li> <li>执行构造函数</li> <li>如果构造函数返回一个非空对象，则返回该对象，否则返回之前创建的新对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> obj <span class="token operator">:</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="函数防抖和函数节流-2"><a href="#函数防抖和函数节流-2" class="header-anchor">#</a> 函数防抖和函数节流</h2> <p>函数防抖和函数节流可以避免时间频繁触发而耗费性能，例如：联想搜索、滚动监听、避免按钮重复点击等。</p> <ul><li>函数防抖（<code>debounce</code>）：触发事件一段时间后才执行，如果期间重复触发，则重新计时</li> <li>函数节流（<code>throttle</code>）：事件在一段时间内只会触发一次</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">200</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">200</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用时间戳定义的函数节流：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">200</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> previous <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      previous <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="手写-ajax"><a href="#手写-ajax" class="header-anchor">#</a> 手写 AJAX</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'https://api.github.com/users/JungleHico'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="手写深拷贝"><a href="#手写深拷贝" class="header-anchor">#</a> 手写深拷贝</h2> <p>深拷贝需要递归遍历对象的属性，如果该属性时基本数据类型，直接返回，如果是引用类型，则递归创建其副本，然后添加到对象的属性上，实现的时候需要区分是不是数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">cloneDeep</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      object<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">cloneDeep</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cloneDeep</span><span class="token punctuation">(</span>object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="手写数组-push-方法"><a href="#手写数组-push-方法" class="header-anchor">#</a> 手写数组 push() 方法</h2> <p><code>push()</code> 是数组的共享方法，需要写在其原型链上，<code>push()</code> 接受一个参数列表，会将这些参数添加到数组的尾部，然后返回数组的长度。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_push</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="手写数组-map-方法"><a href="#手写数组-map-方法" class="header-anchor">#</a> 手写数组 map() 方法</h2> <p><code>map()</code> 是数组的共享方法，需要写在其原型链上，<code>map()</code> 接受一个回调函数，返回原数组的副本，数组中的每一项执行回调函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_map</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callbackFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callbackFn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackFn<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not a function</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h3> <ol><li>方法一：<code>filter()</code>：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>方法二：<code>Set()</code>：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>方法三：<code>Map()</code>：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h2> <p>第一次遍历，每个元素和下一个元素比较，如果比下一个元素打，则交换这两个元素的位置，最终最大的元素会以“冒泡”的形式排在最后；</p> <p>第二次遍历，把第二大的元素排到倒数第二位；</p> <p>以此类推，直到数组完成排序。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h2> <p>选择排序从第一个数开始遍历，记录最小值，如果当前元素比之前记录的最小值小，则更新最小值，循环结束后，把最小值排到第二位；</p> <p>第二次遍历，从第二个数开始记录和遍历，以此类推，直至数组完成排序。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> list<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="直接插入排序"><a href="#直接插入排序" class="header-anchor">#</a> 直接插入排序</h2> <p>直接插入排序将数组分为两部分，已排序和未排序，初始时已排序包含第一个元素，未排序部分从第二个元素开始；</p> <p>每次遍历时，取出未排序部分的第一个元素，与已排序的元素逐个进行比较（一般是从后往前），插入到正确的位置，直到所有元素都完成排序。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token punctuation">[</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="折半-二分-插入排序"><a href="#折半-二分-插入排序" class="header-anchor">#</a> 折半（二分）插入排序</h2> <p>折半插入排序的原理和直接插入排序差不多，只不过在比较元素大小时，不是逐个进行比较，而是将未排序元素与已排序数组的中间值进行比较：</p> <p>如果大于中间值，则以相同方法比较中间值之后的元素；</p> <p>否则以相同方法比较中间值之前的元素；</p> <p>当找到元素的正确位置后，将该位置后面的元素后移，将该元素放到该位置。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">binaryInsertSort</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> height <span class="token operator">=</span> list<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> middle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>low <span class="token operator">+</span> height<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        low <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        high <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> tmp <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&gt;</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    list<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h2> <p>快排以一个数作为基准值，例如第一个数，并定义两个索引指针，一个从前往后遍历，一个从后往前遍历：</p> <p>首先从后往前遍历，找到第一个比基准值小的元素，然后从前往后遍历，找到第一个比基准值大的元素，交换这两个元素的位置；</p> <p>当前后两个指针重叠时，将基准值放到指针重叠位置，这样比基准值小的值都位于基准值前面，比基准值大的值都位于基准值后面；</p> <p>以基准值为分割点，将数组分成两个区间，两个区间分别使用以上方法进行排序，当区间只剩一个元素时，完成排序。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">list<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> low <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">let</span> high <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">let</span> base <span class="token operator">=</span> low<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> list<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> list<span class="token punctuation">[</span>base<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        high<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> list<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> list<span class="token punctuation">[</span>base<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        low<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token punctuation">[</span>list<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span>list<span class="token punctuation">[</span>base<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>base<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> left<span class="token punctuation">,</span> low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="typescript-常见面试题"><a href="#typescript-常见面试题" class="header-anchor">#</a> TypeScript 常见面试题</h1> <h2 id="什么是-typescript"><a href="#什么是-typescript" class="header-anchor">#</a> 什么是 TypeScript</h2> <p>TypeScript 是一个强类型的 JavaScript 超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等。TypeScript 并不直接在浏览器上运行，需要编译器编译成纯 Javascript 来运行。</p> <h2 id="ts-中-any-的作用"><a href="#ts-中-any-的作用" class="header-anchor">#</a> TS 中 any 的作用</h2> <p>为编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。</p> <h2 id="ts-中的访问修饰符"><a href="#ts-中的访问修饰符" class="header-anchor">#</a> TS 中的访问修饰符</h2> <ul><li><code>private</code>：只在类的内部可以访问</li> <li><code>public</code>：任何地方都可以访问</li> <li><code>protected</code>：在类的内部或者子类中访问</li> <li><code>readonly</code>：属实只读，不能修改</li></ul> <h2 id="ts-中-const-和-readonly-不同"><a href="#ts-中-const-和-readonly-不同" class="header-anchor">#</a> TS 中 const 和 readonly 不同</h2> <ul><li><code>const</code> 用于变量，<code>readonly</code> 用于属性</li> <li><code>const</code> 在运行时检查，<code>readonly</code> 在编译时检查</li></ul> <h2 id="ts-中-any-和-unknown-异同"><a href="#ts-中-any-和-unknown-异同" class="header-anchor">#</a> TS 中 any 和 unknown 异同</h2> <ol><li>任何类型都可以赋值给 <code>any</code> 和 <code>unknown</code></li> <li>与 <code>any</code> 不同，<code>unknown</code> 类型的变量不能直接赋值给非 <code>any</code> 类型或非 <code>unknown</code> 类型的变量，需要使用 <code>typeof</code> 判断类型或者类型断言，因此，<strong>unknown 可以说是类型安全的 any</strong></li></ol> <h2 id="ts-中接口和类型别名有什么异同点"><a href="#ts-中接口和类型别名有什么异同点" class="header-anchor">#</a> TS 中接口和类型别名有什么异同点</h2> <h3 id="相同点"><a href="#相同点" class="header-anchor">#</a> 相同点</h3> <ol><li>都可以描述对象和函数</li></ol> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>都可以被继承</li></ol> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  grade<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 交叉类型</span>
<span class="token keyword">type</span> <span class="token class-name">Student</span> <span class="token operator">=</span> Person <span class="token operator">&amp;</span> <span class="token punctuation">{</span>
  grade<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="不同点"><a href="#不同点" class="header-anchor">#</a> 不同点</h3> <ol><li>除了对象和函数，<code>type</code> 还可以指定基本类型、联合类型、元组等。</li></ol> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Name</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Account</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li><code>interface</code> 可以重复声明，等同于两个接口进行合并。</li></ol> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="ts-中-typeof-和-keyof"><a href="#ts-中-typeof-和-keyof" class="header-anchor">#</a> TS 中 typeof 和 keyof</h2> <ul><li><code>typeof</code>：TS 中 <code>typeof</code> 可以获取变量的声明或者对象的类型。</li> <li><code>keyof</code>：<code>keyof</code> 可以获取某种类型的所有键，返回值是联合类型。</li></ul> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">TypeOfPerson</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> person<span class="token punctuation">;</span> <span class="token comment">// Person</span>
</code></pre></div><div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">KeyOfPerson</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Person<span class="token punctuation">;</span> <span class="token comment">// &quot;name&quot; | &quot;number&quot;</span>
</code></pre></div><h2 id="ts-泛型"><a href="#ts-泛型" class="header-anchor">#</a> TS 泛型</h2> <p>泛型是指在定义函数、接口或类的时候，不指定具体的类型，而是可以和不同类型一起工作，从而实现复用。<strong>简单的说，“泛型就是把类型当成参数”。</strong></p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getValue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token generic-function"><span class="token function">getValue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token generic-function"><span class="token function">getValue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="ts-模块加载机制"><a href="#ts-模块加载机制" class="header-anchor">#</a> TS 模块加载机制</h2> <ol><li>首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式；</li> <li>如果没有查找到对应的模块，编译器会尝试定位一个类型声明文件（<code>*.d.ts</code>）；</li> <li>最后，如果编译器还是不能解析这个模块，则会抛出一个错误。</li></ol> <blockquote><p><code>tsconfig.json</code> 配置文件中，可以通过 <code>files</code>、<code>include</code> 和 <code>exclude</code> 指定编译的文件（<code>*.ts</code>和 <code>*.d.ts</code>）。</p></blockquote> <h2 id="ts-中-declare-用法"><a href="#ts-中-declare-用法" class="header-anchor">#</a> TS 中 declare 用法</h2> <p>在 TS 的类型声明文件中，通过 <code>declare</code> 声明一些全局变量、全局方法、全局对象等。其中，<code>declare global</code> 可以扩展全局变量的类型。</p> <h1 id="webpack-和前端工程化"><a href="#webpack-和前端工程化" class="header-anchor">#</a> Webpack 和前端工程化</h1> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h2> <p>[<a href="https://github.com/JungleHico/webpack-doc" target="_blank" rel="noopener noreferrer">JungleHico/webpack-doc: webpack 使用文档 (github.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>](<a href="https://github.com/JungleHico/webpack-doc" target="_blank" rel="noopener noreferrer">JungleHico/webpack-doc: webpack 使用文档 (github.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <h2 id="webpack-打包过程"><a href="#webpack-打包过程" class="header-anchor">#</a> Webpack 打包过程</h2> <ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。</li> <li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。</li> <li>确定入口：根据配置中的 entry 找出所有的入口文件。</li> <li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li> <li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li> <li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</li> <li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol> <h2 id="webpack-loader-和-plugin"><a href="#webpack-loader-和-plugin" class="header-anchor">#</a> Webpack Loader 和 Plugin</h2> <table><thead><tr><th></th> <th>Loader</th> <th>Plugin</th></tr></thead> <tbody><tr><td>作用</td> <td>webpack 默认只支持编译 js 模块，而通过 loader，webpack 可以支持各种语言和预处理器编写模块。</td> <td>plugin 可以以扩展 webpack 的功能，让 webpack 具有更多的灵活性。</td></tr> <tr><td>加载顺序</td> <td>从后往前</td> <td>从前往后</td></tr></tbody></table> <h2 id="开发环境和生产环境"><a href="#开发环境和生产环境" class="header-anchor">#</a> 开发环境和生产环境</h2> <p>开发环境（<code>development</code>）和生产环境（<code>production</code>）的构建目标差异很大。</p> <ul><li>在开发环境中，我们需要具有强大的、具有实时重新加载（live reloading）或热模块替换（hot module replacement）能力的 source map 和 localhost server。</li> <li>在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。</li></ul> <h2 id="source-map"><a href="#source-map" class="header-anchor">#</a> source-map</h2> <p>当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。webpack 通过 <code>devtool</code> 属性来配置不同的 <code>source-map</code> 值。使用不同的 <code>source-map</code> 值，代码的构建速度和代码映射是不一样的。</p> <ul><li>对于开发环境，通常希望以增加编译后包的体积为代价，获取编译较快速且调试友好的 source map。</li> <li>但是对于生产环境，则希望分离和压缩模块，获得体积较小且不能有原始源代码（可以有行列信息供调试）的 source map。</li></ul> <h2 id="webpack-构建优化"><a href="#webpack-构建优化" class="header-anchor">#</a> Webpack 构建优化</h2> <ol><li>对于生产环境，可以通过 <code>webpack-bundle-analyzer</code> 插件将打包后的结果以矩形树图的方式进行可视化显示，方便我们进行模块分析和性能优化。</li> <li>通过设置 <code>source-map</code> 的值，使开发环境的打包速度更快，生产环境的打包体积更小。</li> <li>通过 <code>thread-loader</code>，利用多线程进行打包。</li> <li>通过 <code>externals</code> 属性，以外部扩展的形式引入代码库，这样就可以通过 CDN 进行加速了。</li> <li>Tree-Shaking，webpack 自带，可以剔除不需要用到的代码。</li></ol> <h2 id="浏览器缓存和代码分离"><a href="#浏览器缓存和代码分离" class="header-anchor">#</a> 浏览器缓存和代码分离</h2> <h2 id="权限控制"><a href="#权限控制" class="header-anchor">#</a> 权限控制</h2> <p>路由权限（菜单权限）、接口权限、动作权限</p> <h2 id="ci-cd"><a href="#ci-cd" class="header-anchor">#</a> CI/CD</h2> <ul><li><p>CI：持续集成，包含代码提交和自动化测试</p></li> <li><p>CD：持续部署，一般指自动化部署</p></li></ul> <p>CI/CD 一般指项目的自动化，常见的方案有 Github Actions、Gitlab Runner 和 Jenlins 等。</p> <h3 id="github-actions"><a href="#github-actions" class="header-anchor">#</a> Github Actions</h3> <p>参考：<a href="https://www.bilibili.com/video/BV1Ca411h7rx/?spm_id_from=333.999.0.0&amp;vd_source=82bae426e35bb536955cd65831b6f5d8" target="_blank" rel="noopener noreferrer">Github Action自动化部署<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，创建和配置工作流配置文件 <code>.github/workflows/main.yml</code>，当 Github 仓库 <code>push</code> 新代码时，自动检查 Node 环境，运行安装项目依赖和项目构建命令，并打包上传到服务器，实现自动化部署。</p> <h3 id="gitlab-runner"><a href="#gitlab-runner" class="header-anchor">#</a> Gitlab Runner</h3> <ol><li>服务器安装 Gitlab Runner</li> <li>服务器注册 Gitlab Runner（需要获取 token，token 分为整个平台、团队和项目3个级别）</li> <li>项目根目录创建 <code>.gitlab-ci.yml</code> 配置文件，指定构建、测试和部署脚本。</li></ol> <h2 id="npm-私服"><a href="#npm-私服" class="header-anchor">#</a> npm 私服</h2> <p>搭建 npm 私服可以提高项目依赖下载速率，也可以管理企业自研的开发包。搭建 npm 私服一般通过 <a href="https://verdaccio.org/zh-cn/docs/what-is-verdaccio/" target="_blank" rel="noopener noreferrer">Verdaccio<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="微前端"><a href="#微前端" class="header-anchor">#</a> 微前端</h2> <p>微前端借鉴了微服务的概念，将一个庞大的应用拆解成若干个独立开发（技术栈独立）、独立运行、松散耦合的应用。常见的微前端框架有：[qiankun](<a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener noreferrer">qiankun - qiankun (umijs.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)、[MicroApp](<a href="https://micro-zoe.github.io/micro-app/" target="_blank" rel="noopener noreferrer">MicroApp (micro-zoe.github.io)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)、[无界](<a href="https://wujie-micro.github.io/doc/" target="_blank" rel="noopener noreferrer">无界 | 极致的微前端框架 (wujie-micro.github.io)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>) 等。</p> <h1 id="计算机网络常见面试题"><a href="#计算机网络常见面试题" class="header-anchor">#</a> 计算机网络常见面试题</h1> <h2 id="计算机网络的五层体系结构"><a href="#计算机网络的五层体系结构" class="header-anchor">#</a> 计算机网络的五层体系结构</h2> <ul><li><strong>应用层</strong>：是通过应用进程间的交互来完成特定网络应用。常见的应用层协议有 HTTP、DNS、SMTP。</li> <li><strong>传输层</strong>：负责向两台主机进程之间的通信提供通用的数据传输服务。传输层主要包含 TCP 和 UDP 两种协议，TCP 是提供<strong>面向连接的</strong>、<strong>可靠的</strong>服务；UDP 提供<strong>无连接</strong>的，尽最大努力的数据传输服务。</li> <li><strong>网络层</strong>：负责为分组交换网上的不同主机提供通信。在 TCP/UDP 协议中，网络层使用 IP 协议，发送 IP 报文。</li> <li><strong>数据链路层</strong>：将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</li> <li><strong>物理层</strong>：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li></ul> <h2 id="在地址栏里输入一个地址回车会发生哪些事情"><a href="#在地址栏里输入一个地址回车会发生哪些事情" class="header-anchor">#</a> 在地址栏里输入一个地址回车会发生哪些事情？</h2> <ol><li>解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li> <li>缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</li> <li>DNS 解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li> <li>获取 MAC 地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</li> <li>TCP 三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</li> <li>HTTPS 握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li> <li>返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</li> <li>页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</li> <li>TCP 四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li></ol> <h2 id="get-请求和-post-请求"><a href="#get-请求和-post-请求" class="header-anchor">#</a> GET 请求和 POST 请求</h2> <table><thead><tr><th></th> <th>GET 请求</th> <th>POST 请求</th></tr></thead> <tbody><tr><td>发送方式</td> <td>通过 URL 发送，参数通过 &amp; 连接</td> <td>发送请求体</td></tr> <tr><td>数据类型</td> <td>只支持 ASCII 字符</td> <td>二进制数据</td></tr> <tr><td>语义</td> <td>用于请求数据</td> <td>用于提交数据</td></tr> <tr><td>缓存</td> <td>能被浏览器缓存，再次访问返回 304</td> <td>不能被浏览器缓存</td></tr> <tr><td>数据长度</td> <td>浏览器对 URL 长度有限制，一般是 2048 个字符</td> <td>无限制</td></tr> <tr><td>数据包</td> <td>一次发送</td> <td>浏览器一般分两次发送，先发送请求头，再发送请求体</td></tr> <tr><td>安全</td> <td>敏感数据放在 URL 请求参数中会暴露</td> <td></td></tr></tbody></table> <h2 id="http1-0-http1-1-和-http2-0-协议"><a href="#http1-0-http1-1-和-http2-0-协议" class="header-anchor">#</a> http1.0，http1.1 和 http2.0 协议</h2> <ul><li>http1.0：每次请求和响应完毕后都会销毁 TCP 连接，而且前一个响应完成后才能发送下一个请求，这就意味着连接无法复用，每次请求都需要重新建立连接，而且如果前一个请求阻塞，会影响后面的请求。</li> <li>http1.1：支持长连接，请求头设置 <code>connection:keep-alive</code>，一段时间内可以复用之前的 TCP 连接；支持管道化，下一个请求不需要等待上一个请求响应完成才开始发送，不过响应顺序必须和发送顺序保持一致，因此也不支持多路复用；支持断点续传。</li> <li>http2.0：采用二进制分帧，每帧都有符号标识，标识该帧属于哪个流，且一个 TCP 连接可以存在多条流，也就是可以发送多个请求（多路复用），这样不再有请求阻塞的问题和响应顺序的限制；头部压缩，头部数据量减少，传输速率提高。</li></ul> <h2 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h2> <p>浏览器缓存策略分为<strong>强缓存</strong>和<strong>协商缓存</strong>两种。</p> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <p>强缓存不会向服务器发请求，而是从缓存中读取资源，强缓存可以通过 response header 的 <code>expires</code> 和 <code>cache-control</code> 进行控制。</p> <p><code>expires</code> 表示缓存的过期时间，有个缺点是受本地时间影响，修改本地时间会影响缓存。</p> <p><code>cache-control</code> 的优先级比 <code>expires</code> 高，有多个取值，最常见的是 <code>max-age</code>，表示缓存的有效时间，比如 <code>cache-control: max-age=600</code> 表示 600 秒后过期。</p> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。协商缓存可以通过 response header 的 <code>last-Modifined</code> 和 <code>etag</code> 进行控制。</p> <p><code>last-modifined</code> 表示文件最后修改时间，当浏览器第二次请求资源时，请求头会添加这个过期时间，服务器会将这个时间和文件最后修改时间比较，如果没有变化，说明资源没有变化，于是返回 304 状态码；如果资源有变化，则返回新的资源，状态码为 200。</p> <p><code>etag</code> 与 <code>last-modefined</code> 类似，只不过是一个 <code>token</code>，发送请求时比较本地 <code>token</code> 与服务器 <code>token</code> 是否一致。<code>etag</code> 的优先级比 <code>last-Modefined</code> 高。</p> <h2 id="cookie-和-storage"><a href="#cookie-和-storage" class="header-anchor">#</a> cookie 和 Storage</h2> <table><thead><tr><th></th> <th>cookie</th> <th>Storage</th></tr></thead> <tbody><tr><td>http 请求</td> <td>发送请求时请求头会包含 cookie</td> <td>Storage 只存储在客户端</td></tr> <tr><td>大小</td> <td>一般 4KB</td> <td>一般 5MB</td></tr> <tr><td>有效期</td> <td>可以设置过期时间，默认浏览器关闭</td> <td><code>localStorage</code> 长期保存，<code>sessionStorage</code> 持续到网页会话被关闭</td></tr></tbody></table> <h2 id="jwt"><a href="#jwt" class="header-anchor">#</a> JWT</h2> <p>JWT（JSON web Token）是一种基于 token 的身份验证和数据交换技术，一般包含三个部分：header、payload 和 signature。</p> <ul><li>header：一般包含签名算法和令牌类型</li> <li>payload：标识主体信息（明文），一般包含令牌过期时间、发布时间、发行者、主体信息等</li> <li>signature：基于特定算法对前两部分加密后的结果，服务端接收后校验加密结果</li></ul> <h2 id="单点登录"><a href="#单点登录" class="header-anchor">#</a> 单点登录</h2> <p>单点登录（Single Sign On）指的是在同一账号平台的多个应用系统中，用户只需要登录一次，即可访问所有相互信任的应用系统，例如登录了百度贴吧的网站，打开其他百度系的网站，例如百度网盘，百度地图等，就会保持登录状态。单点登录常见的实现方式有两种，一种是共享 Cookie，另一种是部署认证中心。</p> <ul><li>共享 Cookie：将 Cookie 的域名设置为主域名，这样所有的子域名的站点中就可以共享 Cookie，从而实现共享登录状态，这种方式的弊端是只能在主域名相同的站点中实现单点登录。</li> <li>部署认证中心：部署一个专门用于处理登录请求的 web 服务，称为认证中心，用户统一在认证中心进行登录，用户登录后，认证中心会创建全局会话，保存用户登录状态，同时系统应用会创建局部会话，并生成 token 回传给客户端。</li></ul> <h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="header-anchor">#</a> 如何解决跨域问题</h2> <ol><li>JSONP</li></ol> <p>JSONP（JSON with padding）是通过动态创建<code>&lt;script&gt;</code> 元素并为 <code>src</code> 属性指定跨域 URL 实现的。JSONP 可以从不同域拉去可执行代码，但不能防止域的恶意代码，而且不能确定 JSONP 请求是否失败。</p> <ol start="2"><li>CORS</li></ol> <p>CORS（Cross-Origin Resource Sharing）跨域资源请求，通过使用自定义 HTTP 头部来实现浏览器与服务器的跨域通讯，服务器端通过 <code>Access-Control-Allow-Origin</code> 匹配浏览器请求。</p> <ol start="3"><li>proxy</li></ol> <p>受浏览器同源策略的影响，浏览器不能跨域访问接口，而服务器不受此策略的影响，所以可以通过本地服务器代理请求，然后访问不同源的接口。</p> <h2 id="常见-web-漏洞"><a href="#常见-web-漏洞" class="header-anchor">#</a> 常见 Web 漏洞</h2> <h3 id="_1-sql-注入"><a href="#_1-sql-注入" class="header-anchor">#</a> 1. SQL 注入</h3> <p>Web 应用程序对用户的输入没有做严格的判断，导致用户可用将非法的 SQL 语句拼接到正常的语句中，被当作 SQL 语句的一部分执行。</p> <h3 id="_2-xss"><a href="#_2-xss" class="header-anchor">#</a> 2. XSS</h3> <p>跨站脚本攻击（Cross-Site Scripting），恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。一般框架都会对 XSS 进行过滤，例如 Vue 的 <code>v-html</code> 指令。</p> <h3 id="_3-csrf"><a href="#_3-csrf" class="header-anchor">#</a> 3. CSRF</h3> <p>CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的 Web 攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以通过设置 Cookie 的 SameSite 设置 Cookie 不能跨域访问，也可以通过 Token 来避免 CSRF 攻击。</p> <h3 id="_4-暴力破解"><a href="#_4-暴力破解" class="header-anchor">#</a> 4. 暴力破解</h3> <p>攻击者通过穷举的方式对用户密码进行爆破。一般通过验证码、非人机验证、密码多次输入错误后延长输入时间、异地登录提示等方式进行防范。</p> <h3 id="_5-文件上传"><a href="#_5-文件上传" class="header-anchor">#</a> 5. 文件上传</h3> <p>攻击者可以上传一个与网站脚本语言相对应的<strong>恶意代码动态脚本</strong>到服务器上，然后访问这些恶意脚本中包含的恶意代码,从而获得了<strong>执行服务器端命令</strong>的能力,进一步影响服务器安全。前端对文件上传的类型进行过滤。</p> <h1 id="vue-常见面试题"><a href="#vue-常见面试题" class="header-anchor">#</a> Vue 常见面试题</h1> <h2 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h2> <p>M（<code>Model</code>），即数据模型；V（<code>View</code>），即视图。</p> <p>传统的开发模式，例如原生 JS 或者 jQuery，视图和模型是不分离的，更新数据时需要先找到视图，即需要更新数据的元素，这种方式当业务逻辑变得复杂之后就会难以维护。</p> <p>MVVM 实现了模型和视图的分离，通过 MV（<code>ViewModel</code>），将数据与视图绑定，更新数据时会自动更新视图，视图变化时也会通知 ViewModel 更新数据。</p> <h2 id="vue-3-响应式数据的基本实现"><a href="#vue-3-响应式数据的基本实现" class="header-anchor">#</a> Vue 3 响应式数据的基本实现</h2> <p>Vue 2 中使用 <code>Object.defineProperty()</code> 来实现对对象属性的读取和设置，Vue 3 中采用 ES6 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 语法。<strong>Proxy 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。</strong> 通过 Proxy 对数据的读取和设置进行拦截，当读对象的属性时，触发 <code>get</code> 函数，将副作用函数存入集合中；当设置对象的属性时，触发 <code>set</code> 函数，从集合中取出副作用函数并执行，这样就实现了简单的响应式数据。</p> <h2 id="vue3-新特性"><a href="#vue3-新特性" class="header-anchor">#</a> Vue3 新特性</h2> <ol><li>引入组合式 API，使业务逻辑关注点更加集中，提高代码复用性和可维护性。</li> <li>更好的 TS 支持。</li> <li>新增 <code>&lt;Teleport&gt;</code> 组件，可以将插槽内容渲染到指定外层 DOM。</li> <li>Fragments，支持多根节点，减少节点层数，提高渲染性能。</li> <li>重构响应式系统，使用 <code>Proxy</code> 代替 Vue 2 的 <code>Object.defineProperty</code> 实现响应式数据。</li> <li>新增静态标记（patchFlag）（编译器），提高渲染效率（渲染器）。</li></ol> <h2 id="为什么-data-选项需要通过一个函数返回一个对象"><a href="#为什么-data-选项需要通过一个函数返回一个对象" class="header-anchor">#</a> 为什么 data 选项需要通过一个函数返回一个对象？</h2> <p>如果 <code>data</code> 直接指定一个对象，那么多个组件就会引用同一个数据，一个组件修改数据会污染其他组件的数据。通过一个函数返回数据对象，可以通过函数作用域进行隔离。</p> <h2 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="header-anchor">#</a> v-if 和 v-show</h2> <p><code>v-if</code> 是<strong>真实</strong>的条件渲染，是<strong>惰性</strong>的，只有当表达式的值为 <code>true</code> 时才会被渲染，当表达式的值为 <code>false</code> 时不会渲染，并且会销毁原有的元素。</p> <p><code>v-show</code> 元素始终会被渲染，只是通过 CSS 的 <code>display</code> 属性控制元素的显示与隐藏。</p> <p><code>v-if</code> 具有更高的切换开销，而 <code>v-show</code> 具有更高的初始化渲染开销。</p> <h2 id="为什么不推荐同时使用-v-for-和-v-if-v-for-和-v-if-优先级"><a href="#为什么不推荐同时使用-v-for-和-v-if-v-for-和-v-if-优先级" class="header-anchor">#</a> 为什么不推荐同时使用 v-for 和 v-if（v-for 和 v-if 优先级）</h2> <ul><li>Vue 2 中 <code>v-for</code> 的优先级比 <code>v-if</code> 高，<code>v-if</code> 会重复运行在每个 <code>v-for</code> 循环中，如果想要有条件的跳过循环，则可以将 <code>v-if</code> 至于外层；</li> <li>Vue 3 中 <code>v-if</code> 的优先级比 <code>v-for</code> 高，这意味着 <code>v-if</code> 无法访问 <code>v-for</code> 的作用域内的变量。</li></ul> <h2 id="为什么推荐为-v-for-提供-key"><a href="#为什么推荐为-v-for-提供-key" class="header-anchor">#</a> 为什么推荐为 v-for 提供 key</h2> <p>Vue 默认按照“就地更新”的策略来更新通过 <code>v-for</code> 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p> <p>默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p> <p>为每个元素指定唯一的 <code>key</code> 属性，Vue 执行 Diff 算法更新节点时，就可以根据标识重用和重新排列现有元素。</p> <h2 id="为什么-vue-3-的-setup-函数中不能使用-this"><a href="#为什么-vue-3-的-setup-函数中不能使用-this" class="header-anchor">#</a> 为什么 Vue 3 的 setup 函数中不能使用 this？</h2> <p>因为 <code>setup</code> 函数在组件创建之前执行，所以 <code>setup</code> 函数中的 <code>this</code> 并不是组件实例的引用，因此应当避免在 <code>setup</code> 函数中使用 <code>this</code>。</p> <h2 id="如何理解-vue-的单向数据流"><a href="#如何理解-vue-的单向数据流" class="header-anchor">#</a> 如何理解 Vue 的单向数据流</h2> <p>所有的 props 都遵循着<strong>单向绑定</strong>原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p> <h2 id="computed-和-watch"><a href="#computed-和-watch" class="header-anchor">#</a> computed 和 watch</h2> <ol><li><code>computed</code> <strong>支持缓存</strong>，只在相关响应式依赖发生改变时，才会重新求值；<code>watch</code> <strong>不支持缓存</strong>，只要数据发生变化，就会执行侦听函数。</li> <li><code>computed</code> 的职责仅为计算和返回值，不应该有其他副作用（<strong>异步请求或更改 DOM</strong>）；<code>watch</code> 相对更加通用，<strong>适合执行异步或者开销较大的操作</strong>。</li></ol> <h2 id="vue-组件传参方法"><a href="#vue-组件传参方法" class="header-anchor">#</a> vue 组件传参方法</h2> <ol><li>父组件通过 <code>props</code> 传数据给子组件</li> <li>子组件通过 <code>emit</code> 自定义事件传递数据</li> <li>祖先组件通过 <code>provide</code> 传递数据，后代组件通过 <code>inject</code> 接受数据</li> <li>父组件通过 <code>refs</code> 获取子组件实例</li> <li>Vue 2 eventBus</li> <li>状态管理 Vuex/Pinia</li></ol> <h2 id="vue-3-中代码复用的方式"><a href="#vue-3-中代码复用的方式" class="header-anchor">#</a> Vue 3 中代码复用的方式</h2> <ol><li><strong>组件</strong>：构建模块和 HTML 代码的复用</li> <li><strong>组合式函数</strong>：逻辑（JS 代码）的复用，例如把某个业务封装到 <code>useXXX()</code> 函数中然后导出。</li> <li><strong>自定义指令</strong>：复用 HTML 元素的 DOM 操作，比如元素自动聚焦、图片懒加载。</li></ol> <h2 id="vue-3-内置组件"><a href="#vue-3-内置组件" class="header-anchor">#</a> Vue 3 内置组件</h2> <ul><li>Transition、TransitonGroup</li> <li>KeepAlive</li> <li>Teleport</li></ul> <h2 id="keepalive"><a href="#keepalive" class="header-anchor">#</a> keepAlive</h2> <p><code>&lt;keep-alive&gt;</code> 是 Vue 的一个内置组件，可以缓存组件，当组件切换时不会被销毁。</p> <ul><li><code>&lt;keep-alive&gt;</code> 默认会缓存所有组件，可以通过 <code>include/exclude</code> 控制要缓存的组件。</li> <li>可以通过 <code>onActivated()</code> 和 <code>onDeactivated</code> 生命周期监听组件的显示/隐藏。</li></ul> <h2 id="vue-router-history-模式和-hash-模式"><a href="#vue-router-history-模式和-hash-模式" class="header-anchor">#</a> vue-router history 模式和 hash 模式</h2> <table><thead><tr><th></th> <th>hash 模式</th> <th>history 模式</th></tr></thead> <tbody><tr><td>url</td> <td>包含哈希符号 <code>#</code></td> <td>不包含 <code>#</code></td></tr> <tr><td>无刷新实现</td> <td>通过 <code>window.onhashchange</code> 来监听 <code>hash</code> 的变化，借此实现无刷新跳转</td> <td>通过 <code>history.pushState</code> 和 <code>history.replaceState</code> 来实现无刷新跳转</td></tr> <tr><td>服务器配置</td> <td>不需要服务器层面做处理</td> <td>服务器需要配置回退路由，否则会出现刷新页面404的问题</td></tr> <tr><td>SEO</td> <td><code>hash</code> 模式的页面跳转都在客户端中，不利于 SEO</td> <td>SEO 友好</td></tr></tbody></table> <h2 id="vue-路由守卫"><a href="#vue-路由守卫" class="header-anchor">#</a> Vue 路由守卫</h2> <ul><li>全局路由守卫：<code>beforeEach</code>、<code>beforerResolve</code>、<code>AfterEach</code></li> <li>路由独享守卫：<code>beforeEnter</code></li> <li>组件内守卫：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.31678b28.js" defer></script><script src="/assets/js/2.62c74a10.js" defer></script><script src="/assets/js/34.7bd49029.js" defer></script><script src="/assets/js/6.a591d526.js" defer></script>
  </body>
</html>
